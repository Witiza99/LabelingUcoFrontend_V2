{"ast":null,"code":"/**\n * ExifReader\n * http://github.com/mattiasw/exifreader\n * Copyright (C) 2011-2023  Mattias Wallander <mattias@wallander.eu>\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* global Buffer, __non_webpack_require__ */\n\nimport { objectAssign, dataUriToBuffer } from './utils.js';\nimport DataViewWrapper from './dataview.js';\nimport Constants from './constants.js';\nimport { getStringValueFromArray } from './utils.js';\nimport { getCalculatedGpsValue } from './tag-names-utils.js';\nimport ImageHeader from './image-header.js';\nimport Tags from './tags.js';\nimport MpfTags from './mpf-tags.js';\nimport FileTags from './file-tags.js';\nimport JfifTags from './jfif-tags.js';\nimport IptcTags from './iptc-tags.js';\nimport XmpTags from './xmp-tags.js';\nimport PhotoshopTags from './photoshop-tags.js';\nimport IccTags from './icc-tags.js';\nimport PngFileTags from './png-file-tags.js';\nimport PngTextTags from './png-text-tags.js';\nimport PngTags from './png-tags.js';\nimport Vp8xTags from './vp8x-tags.js';\nimport GifFileTags from './gif-file-tags.js';\nimport Thumbnail from './thumbnail.js';\nimport exifErrors from './errors.js';\nexport default {\n  load,\n  loadView,\n  errors: exifErrors\n};\nexport const errors = exifErrors;\nexport function load(data, options = {}) {\n  if (isFilePathOrURL(data)) {\n    options.async = true;\n    return loadFile(data, options).then(fileContents => loadFromData(fileContents, options));\n  }\n  if (isBrowserFileObject(data)) {\n    options.async = true;\n    return loadFileObject(data).then(fileContents => loadFromData(fileContents, options));\n  }\n  return loadFromData(data, options);\n}\nfunction isFilePathOrURL(data) {\n  return typeof data === 'string';\n}\nfunction loadFile(filename, options) {\n  if (/^\\w+:\\/\\//.test(filename)) {\n    if (typeof fetch !== 'undefined') {\n      return fetchRemoteFile(filename, options);\n    }\n    return nodeGetRemoteFile(filename, options);\n  }\n  if (isDataUri(filename)) {\n    return Promise.resolve(dataUriToBuffer(filename));\n  }\n  return loadLocalFile(filename, options);\n}\nfunction fetchRemoteFile(url, {\n  length\n} = {}) {\n  const options = {\n    method: 'GET'\n  };\n  if (Number.isInteger(length) && length >= 0) {\n    options.headers = {\n      range: `bytes=0-${length - 1}`\n    };\n  }\n  return fetch(url, options).then(response => response.arrayBuffer());\n}\nfunction nodeGetRemoteFile(url, {\n  length\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const options = {};\n    if (Number.isInteger(length) && length >= 0) {\n      options.headers = {\n        range: `bytes=0-${length - 1}`\n      };\n    }\n    const get = requireNodeGet(url);\n    get(url, options, response => {\n      if (response.statusCode >= 200 && response.statusCode <= 299) {\n        const data = [];\n        response.on('data', chunk => data.push(Buffer.from(chunk)));\n        response.on('error', error => reject(error));\n        response.on('end', () => resolve(Buffer.concat(data)));\n      } else {\n        reject(`Could not fetch file: ${response.statusCode} ${response.statusMessage}`);\n        response.resume();\n      }\n    }).on('error', error => reject(error));\n  });\n}\nfunction requireNodeGet(url) {\n  if (/^https:\\/\\//.test(url)) {\n    return __non_webpack_require__('https').get;\n  }\n  return __non_webpack_require__('http').get;\n}\nfunction isDataUri(filename) {\n  return /^data:[^;,]*(;base64)?,/.test(filename);\n}\nfunction loadLocalFile(filename, {\n  length\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const fs = requireNodeFs();\n    fs.open(filename, (error, fd) => {\n      if (error) {\n        reject(error);\n      } else {\n        fs.stat(filename, (error, stat) => {\n          if (error) {\n            reject(error);\n          } else {\n            const size = Math.min(stat.size, length !== undefined ? length : stat.size);\n            const buffer = Buffer.alloc(size);\n            const options = {\n              buffer,\n              length: size\n            };\n            fs.read(fd, options, error => {\n              if (error) {\n                reject(error);\n              } else {\n                fs.close(fd, error => {\n                  if (error) {\n                    console.warn(`Could not close file ${filename}:`, error); // eslint-disable-line no-console\n                  }\n                  resolve(buffer);\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  });\n}\nfunction requireNodeFs() {\n  try {\n    return __non_webpack_require__('fs');\n  } catch (error) {\n    return undefined;\n  }\n}\nfunction isBrowserFileObject(data) {\n  return typeof window !== 'undefined' && typeof File !== 'undefined' && data instanceof File;\n}\nfunction loadFileObject(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = readerEvent => resolve(readerEvent.target.result);\n    reader.onerror = () => reject(reader.error);\n    reader.readAsArrayBuffer(file);\n  });\n}\nfunction loadFromData(data, options) {\n  if (isNodeBuffer(data)) {\n    // File data read in Node can share the underlying buffer with other\n    // data. Therefore it's safest to get a new one to avoid weird bugs.\n    data = new Uint8Array(data).buffer;\n  }\n  return loadView(getDataView(data), options);\n}\nfunction isNodeBuffer(data) {\n  try {\n    return Buffer.isBuffer(data);\n  } catch (error) {\n    return false;\n  }\n}\nfunction getDataView(data) {\n  try {\n    return new DataView(data);\n  } catch (error) {\n    return new DataViewWrapper(data);\n  }\n}\nexport function loadView(dataView, {\n  expanded = false,\n  async = false,\n  includeUnknown = false\n} = {\n  expanded: false,\n  async: false,\n  includeUnknown: false\n}) {\n  let foundMetaData = false;\n  let tags = {};\n  const tagsPromises = [];\n  const {\n    fileType,\n    fileDataOffset,\n    jfifDataOffset,\n    tiffHeaderOffset,\n    iptcDataOffset,\n    xmpChunks,\n    iccChunks,\n    mpfDataOffset,\n    pngHeaderOffset,\n    pngTextChunks,\n    pngChunkOffsets,\n    vp8xChunkOffset,\n    gifHeaderOffset\n  } = ImageHeader.parseAppMarkers(dataView, async);\n  if (Constants.USE_JPEG && Constants.USE_FILE && hasFileData(fileDataOffset)) {\n    foundMetaData = true;\n    const readTags = FileTags.read(dataView, fileDataOffset);\n    if (expanded) {\n      tags.file = readTags;\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if (Constants.USE_JPEG && Constants.USE_JFIF && hasJfifData(jfifDataOffset)) {\n    foundMetaData = true;\n    const readTags = JfifTags.read(dataView, jfifDataOffset);\n    if (expanded) {\n      tags.jfif = readTags;\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if (Constants.USE_EXIF && hasExifData(tiffHeaderOffset)) {\n    foundMetaData = true;\n    const readTags = Tags.read(dataView, tiffHeaderOffset, includeUnknown);\n    if (readTags.Thumbnail) {\n      tags.Thumbnail = readTags.Thumbnail;\n      delete readTags.Thumbnail;\n    }\n    if (expanded) {\n      tags.exif = readTags;\n      addGpsGroup(tags);\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n    if (Constants.USE_TIFF && Constants.USE_IPTC && readTags['IPTC-NAA'] && !hasIptcData(iptcDataOffset)) {\n      const readIptcTags = IptcTags.read(readTags['IPTC-NAA'].value, 0, includeUnknown);\n      if (expanded) {\n        tags.iptc = readIptcTags;\n      } else {\n        tags = objectAssign({}, tags, readIptcTags);\n      }\n    }\n    if (Constants.USE_TIFF && Constants.USE_XMP && readTags['ApplicationNotes'] && !hasXmpData(xmpChunks)) {\n      const readXmpTags = XmpTags.read(getStringValueFromArray(readTags['ApplicationNotes'].value));\n      if (expanded) {\n        tags.xmp = readXmpTags;\n      } else {\n        delete readXmpTags._raw;\n        tags = objectAssign({}, tags, readXmpTags);\n      }\n    }\n    if (Constants.USE_PHOTOSHOP && readTags['ImageSourceData']) {\n      const readPhotoshopTags = PhotoshopTags.read(readTags['PhotoshopSettings'].value, includeUnknown);\n      if (expanded) {\n        tags.photoshop = readPhotoshopTags;\n      } else {\n        tags = objectAssign({}, tags, readPhotoshopTags);\n      }\n    }\n    if (Constants.USE_TIFF && Constants.USE_ICC && readTags['ICC_Profile'] && !hasIccData(iccChunks)) {\n      const readIccTags = IccTags.read(readTags['ICC_Profile'].value, [{\n        offset: 0,\n        length: readTags['ICC_Profile'].value.length,\n        chunkNumber: 1,\n        chunksTotal: 1\n      }]);\n      if (expanded) {\n        tags.icc = readIccTags;\n      } else {\n        tags = objectAssign({}, tags, readIccTags);\n      }\n    }\n  }\n  if (Constants.USE_JPEG && Constants.USE_IPTC && hasIptcData(iptcDataOffset)) {\n    foundMetaData = true;\n    const readTags = IptcTags.read(dataView, iptcDataOffset, includeUnknown);\n    if (expanded) {\n      tags.iptc = readTags;\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if (Constants.USE_XMP && hasXmpData(xmpChunks)) {\n    foundMetaData = true;\n    const readTags = XmpTags.read(dataView, xmpChunks);\n    if (expanded) {\n      tags.xmp = readTags;\n    } else {\n      delete readTags._raw;\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if ((Constants.USE_JPEG || Constants.USE_WEBP) && Constants.USE_ICC && hasIccData(iccChunks)) {\n    foundMetaData = true;\n    const readTags = IccTags.read(dataView, iccChunks, async);\n    if (readTags instanceof Promise) {\n      tagsPromises.push(readTags.then(addIccTags));\n    } else {\n      addIccTags(readTags);\n    }\n  }\n  if (Constants.USE_MPF && hasMpfData(mpfDataOffset)) {\n    foundMetaData = true;\n    const readMpfTags = MpfTags.read(dataView, mpfDataOffset, includeUnknown);\n    if (expanded) {\n      tags.mpf = readMpfTags;\n    } else {\n      tags = objectAssign({}, tags, readMpfTags);\n    }\n  }\n  if (Constants.USE_PNG && Constants.USE_PNG_FILE && hasPngFileData(pngHeaderOffset)) {\n    foundMetaData = true;\n    const readTags = PngFileTags.read(dataView, pngHeaderOffset);\n    if (expanded) {\n      tags.png = !tags.png ? readTags : objectAssign({}, tags.png, readTags);\n      tags.pngFile = readTags;\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if (Constants.USE_PNG && hasPngTextData(pngTextChunks)) {\n    foundMetaData = true;\n    const {\n      readTags,\n      readTagsPromise\n    } = PngTextTags.read(dataView, pngTextChunks, async, includeUnknown);\n    addPngTextTags(readTags);\n    if (readTagsPromise) {\n      tagsPromises.push(readTagsPromise.then(tagList => tagList.forEach(addPngTextTags)));\n    }\n  }\n  if (Constants.USE_PNG && hasPngData(pngChunkOffsets)) {\n    foundMetaData = true;\n    const readTags = PngTags.read(dataView, pngChunkOffsets);\n    if (expanded) {\n      tags.png = !tags.png ? readTags : objectAssign({}, tags.png, readTags);\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if (Constants.USE_WEBP && hasVp8xData(vp8xChunkOffset)) {\n    foundMetaData = true;\n    const readTags = Vp8xTags.read(dataView, vp8xChunkOffset);\n    if (expanded) {\n      tags.riff = !tags.riff ? readTags : objectAssign({}, tags.riff, readTags);\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  if (Constants.USE_GIF && hasGifFileData(gifHeaderOffset)) {\n    foundMetaData = true;\n    const readTags = GifFileTags.read(dataView, gifHeaderOffset);\n    if (expanded) {\n      tags.gif = !tags.gif ? readTags : objectAssign({}, tags.gif, readTags);\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  const thumbnail = (Constants.USE_JPEG || Constants.USE_WEBP) && Constants.USE_EXIF && Constants.USE_THUMBNAIL && Thumbnail.get(dataView, tags.Thumbnail, tiffHeaderOffset);\n  if (thumbnail) {\n    foundMetaData = true;\n    tags.Thumbnail = thumbnail;\n  } else {\n    delete tags.Thumbnail;\n  }\n  if (fileType) {\n    if (expanded) {\n      if (!tags.file) {\n        tags.file = {};\n      }\n      tags.file.FileType = fileType;\n    } else {\n      tags.FileType = fileType;\n    }\n    foundMetaData = true;\n  }\n  if (!foundMetaData) {\n    throw new exifErrors.MetadataMissingError();\n  }\n  if (async) {\n    return Promise.all(tagsPromises).then(() => tags);\n  }\n  return tags;\n  function addIccTags(readTags) {\n    if (expanded) {\n      tags.icc = readTags;\n    } else {\n      tags = objectAssign({}, tags, readTags);\n    }\n  }\n  function addPngTextTags(readTags) {\n    if (expanded) {\n      for (const group of ['exif', 'iptc']) {\n        const groupKey = `__${group}`;\n        if (readTags[groupKey]) {\n          tags[group] = !tags[group] ? readTags[groupKey] : objectAssign({}, tags.exif, readTags[groupKey]);\n          delete readTags[groupKey];\n        }\n      }\n      tags.png = !tags.png ? readTags : objectAssign({}, tags.png, readTags);\n      tags.pngText = !tags.pngText ? readTags : objectAssign({}, tags.png, readTags);\n    } else {\n      tags = objectAssign({}, tags, readTags.__exif ? readTags.__exif : {}, readTags.__iptc ? readTags.__iptc : {}, readTags);\n      delete tags.__exif;\n      delete tags.__iptc;\n    }\n  }\n}\nfunction hasFileData(fileDataOffset) {\n  return fileDataOffset !== undefined;\n}\nfunction hasJfifData(jfifDataOffset) {\n  return jfifDataOffset !== undefined;\n}\nfunction hasExifData(tiffHeaderOffset) {\n  return tiffHeaderOffset !== undefined;\n}\nfunction addGpsGroup(tags) {\n  if (tags.exif) {\n    if (tags.exif.GPSLatitude && tags.exif.GPSLatitudeRef) {\n      try {\n        tags.gps = tags.gps || {};\n        tags.gps.Latitude = getCalculatedGpsValue(tags.exif.GPSLatitude.value);\n        if (tags.exif.GPSLatitudeRef.value.join('') === 'S') {\n          tags.gps.Latitude = -tags.gps.Latitude;\n        }\n      } catch (error) {\n        // Ignore.\n      }\n    }\n    if (tags.exif.GPSLongitude && tags.exif.GPSLongitudeRef) {\n      try {\n        tags.gps = tags.gps || {};\n        tags.gps.Longitude = getCalculatedGpsValue(tags.exif.GPSLongitude.value);\n        if (tags.exif.GPSLongitudeRef.value.join('') === 'W') {\n          tags.gps.Longitude = -tags.gps.Longitude;\n        }\n      } catch (error) {\n        // Ignore.\n      }\n    }\n    if (tags.exif.GPSAltitude && tags.exif.GPSAltitudeRef) {\n      try {\n        tags.gps = tags.gps || {};\n        tags.gps.Altitude = tags.exif.GPSAltitude.value[0] / tags.exif.GPSAltitude.value[1];\n        if (tags.exif.GPSAltitudeRef.value === 1) {\n          tags.gps.Altitude = -tags.gps.Altitude;\n        }\n      } catch (error) {\n        // Ignore.\n      }\n    }\n  }\n}\nfunction hasIptcData(iptcDataOffset) {\n  return iptcDataOffset !== undefined;\n}\nfunction hasXmpData(xmpChunks) {\n  return Array.isArray(xmpChunks) && xmpChunks.length > 0;\n}\nfunction hasIccData(iccDataOffsets) {\n  return Array.isArray(iccDataOffsets) && iccDataOffsets.length > 0;\n}\nfunction hasMpfData(mpfDataOffset) {\n  return mpfDataOffset !== undefined;\n}\nfunction hasPngFileData(pngFileDataOffset) {\n  return pngFileDataOffset !== undefined;\n}\nfunction hasPngTextData(pngTextChunks) {\n  return pngTextChunks !== undefined;\n}\nfunction hasPngData(pngChunkOffsets) {\n  return pngChunkOffsets !== undefined;\n}\nfunction hasVp8xData(vp8xChunkOffset) {\n  return vp8xChunkOffset !== undefined;\n}\nfunction hasGifFileData(gifHeaderOffset) {\n  return gifHeaderOffset !== undefined;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}