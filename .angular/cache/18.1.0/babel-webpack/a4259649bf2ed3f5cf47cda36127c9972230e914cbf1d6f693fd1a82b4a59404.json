{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Specification: http://www.libpng.org/pub/png/spec/1.2/\n\nimport { getStringFromDataView, getNullTerminatedStringFromDataView } from './utils.js';\nimport Constants from './constants.js';\nexport default {\n  isPngFile,\n  findPngOffsets\n};\nconst PNG_ID = '\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a';\nconst PNG_CHUNK_LENGTH_SIZE = 4;\nexport const PNG_CHUNK_TYPE_SIZE = 4;\nexport const PNG_CHUNK_LENGTH_OFFSET = 0;\nexport const PNG_CHUNK_TYPE_OFFSET = PNG_CHUNK_LENGTH_SIZE;\nexport const PNG_CHUNK_DATA_OFFSET = PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE;\nconst PNG_XMP_PREFIX = 'XML:com.adobe.xmp\\x00';\nexport const TYPE_TEXT = 'tEXt';\nexport const TYPE_ITXT = 'iTXt';\nexport const TYPE_ZTXT = 'zTXt';\nexport const TYPE_PHYS = 'pHYs';\nexport const TYPE_TIME = 'tIME';\nexport const TYPE_EXIF = 'eXIf';\nexport const TYPE_ICCP = 'iCCP';\nfunction isPngFile(dataView) {\n  return !!dataView && getStringFromDataView(dataView, 0, PNG_ID.length) === PNG_ID;\n}\nfunction findPngOffsets(dataView, async) {\n  const PNG_CRC_SIZE = 4;\n  const offsets = {\n    hasAppMarkers: false\n  };\n  let offset = PNG_ID.length;\n  while (offset + PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE <= dataView.byteLength) {\n    if (Constants.USE_PNG_FILE && isPngImageHeaderChunk(dataView, offset)) {\n      offsets.hasAppMarkers = true;\n      offsets.pngHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;\n    } else if (Constants.USE_XMP && isPngXmpChunk(dataView, offset)) {\n      const dataOffset = getPngXmpDataOffset(dataView, offset);\n      if (dataOffset !== undefined) {\n        offsets.hasAppMarkers = true;\n        offsets.xmpChunks = [{\n          dataOffset,\n          length: dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET) - (dataOffset - (offset + PNG_CHUNK_DATA_OFFSET))\n        }];\n      }\n    } else if (isPngTextChunk(dataView, offset, async)) {\n      offsets.hasAppMarkers = true;\n      const chunkType = getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n      if (!offsets.pngTextChunks) {\n        offsets.pngTextChunks = [];\n      }\n      offsets.pngTextChunks.push({\n        length: dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET),\n        type: chunkType,\n        offset: offset + PNG_CHUNK_DATA_OFFSET\n      });\n    } else if (isPngExifChunk(dataView, offset)) {\n      offsets.hasAppMarkers = true;\n      offsets.tiffHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;\n    } else if (Constants.USE_ICC && async && isPngIccpChunk(dataView, offset)) {\n      offsets.hasAppMarkers = true;\n      const chunkDataLength = dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET);\n      const iccHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;\n      const {\n        profileName,\n        compressionMethod,\n        compressedProfileOffset\n      } = parseIccHeader(dataView, iccHeaderOffset);\n      if (!offsets.iccChunks) {\n        offsets.iccChunks = [];\n      }\n      offsets.iccChunks.push({\n        offset: compressedProfileOffset,\n        length: chunkDataLength - (compressedProfileOffset - iccHeaderOffset),\n        chunkNumber: 1,\n        chunksTotal: 1,\n        profileName,\n        compressionMethod\n      });\n    } else if (isPngChunk(dataView, offset)) {\n      offsets.hasAppMarkers = true;\n      if (!offsets.pngChunkOffsets) {\n        offsets.pngChunkOffsets = [];\n      }\n      offsets.pngChunkOffsets.push(offset + PNG_CHUNK_LENGTH_OFFSET);\n    }\n    offset += dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET) + PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE + PNG_CRC_SIZE;\n  }\n  return offsets;\n}\nfunction isPngImageHeaderChunk(dataView, offset) {\n  const PNG_CHUNK_TYPE_IMAGE_HEADER = 'IHDR';\n  return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === PNG_CHUNK_TYPE_IMAGE_HEADER;\n}\nfunction isPngXmpChunk(dataView, offset) {\n  return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === TYPE_ITXT && getStringFromDataView(dataView, offset + PNG_CHUNK_DATA_OFFSET, PNG_XMP_PREFIX.length) === PNG_XMP_PREFIX;\n}\nfunction isPngTextChunk(dataView, offset, async) {\n  const chunkType = getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n  return chunkType === TYPE_TEXT || chunkType === TYPE_ITXT || chunkType === TYPE_ZTXT && async;\n}\nfunction isPngExifChunk(dataView, offset) {\n  return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === TYPE_EXIF;\n}\nfunction isPngIccpChunk(dataView, offset) {\n  return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === TYPE_ICCP;\n}\nfunction isPngChunk(dataView, offset) {\n  const SUPPORTED_PNG_CHUNK_TYPES = [TYPE_PHYS, TYPE_TIME];\n  const chunkType = getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n  return SUPPORTED_PNG_CHUNK_TYPES.includes(chunkType);\n}\nfunction getPngXmpDataOffset(dataView, offset) {\n  const COMPRESSION_FLAG_SIZE = 1;\n  const COMPRESSION_METHOD_SIZE = 1;\n  offset += PNG_CHUNK_DATA_OFFSET + PNG_XMP_PREFIX.length + COMPRESSION_FLAG_SIZE + COMPRESSION_METHOD_SIZE;\n  let numberOfNullSeparators = 0;\n  while (numberOfNullSeparators < 2 && offset < dataView.byteLength) {\n    if (dataView.getUint8(offset) === 0x00) {\n      numberOfNullSeparators++;\n    }\n    offset++;\n  }\n  if (numberOfNullSeparators < 2) {\n    return undefined;\n  }\n  return offset;\n}\nfunction parseIccHeader(dataView, offset) {\n  const NULL_SEPARATOR_SIZE = 1;\n  const COMPRESSION_METHOD_SIZE = 1;\n  const profileName = getNullTerminatedStringFromDataView(dataView, offset);\n  offset += profileName.length + NULL_SEPARATOR_SIZE;\n  const compressionMethod = dataView.getUint8(offset);\n  offset += COMPRESSION_METHOD_SIZE;\n  return {\n    profileName,\n    compressionMethod,\n    compressedProfileOffset: offset\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}