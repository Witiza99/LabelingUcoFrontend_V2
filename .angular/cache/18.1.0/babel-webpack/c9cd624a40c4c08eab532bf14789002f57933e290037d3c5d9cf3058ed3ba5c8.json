{"ast":null,"code":"import _asyncToGenerator from \"/home/antoniogg/Escritorio/APPLabelingUCO/pruebamia/FrontendLabelingUCO/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Subject, firstValueFrom } from 'rxjs';\nimport { saveAs } from 'file-saver';\nimport JSZip from 'jszip';\nimport * as ExifReader from 'exifreader';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./spinner.service\";\nimport * as i2 from \"./api-service.service\";\n//Service to manage all Images\nexport let ImageService = /*#__PURE__*/(() => {\n  class ImageService {\n    /*******************************Constructor***********************************/\n    constructor(spinnerService, apiService) {\n      this.spinnerService = spinnerService;\n      this.apiService = apiService;\n      /*******************************Variables***********************************/\n      this.images = [];\n      this.selectedImageIndex = null; // index image for process image\n      this.imagesSubject = new Subject();\n      this.indexSubject = new Subject();\n    }\n    /************************Getter_and_Setter_Funtions***************************/\n    getImages() {\n      return this.images;\n    }\n    //observer for image with metadata vector\n    getImagesObservable() {\n      return this.imagesSubject.asObservable();\n    }\n    //observer for index\n    getIndexObservable() {\n      return this.indexSubject.asObservable();\n    }\n    //index of image processing\n    setSelectedImageIndex(index) {\n      this.selectedImageIndex = index;\n      this.indexSubject.next(this.selectedImageIndex);\n    }\n    /******************************Others_Functions*******************************/\n    //add new image with or without metadata\n    addImages(files) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        for (const file of files) {\n          try {\n            const metadata = yield _this.extractMetadataFromImage(file);\n            const imageWithMetadata = {\n              file,\n              metadata\n            };\n            _this.images.push(imageWithMetadata);\n            console.log(\"Image with metadatos\");\n          } catch (error) {\n            console.log(error);\n            // If not possible get metadata from image, save image without metadata\n            const imageWithMetadata = {\n              file,\n              metadata: null\n            };\n            _this.images.push(imageWithMetadata);\n            console.log(\"Image without metadatos\");\n          }\n        }\n        _this.imagesSubject.next([..._this.images]);\n      })();\n    }\n    //delete image from the tool\n    deleteImage(index) {\n      if (index >= 0 && index < this.images.length) {\n        this.images.splice(index, 1);\n        this.imagesSubject.next([...this.images]);\n      }\n    }\n    //Updata metadata\n    updateMetadata(metadata) {\n      if (this.selectedImageIndex != null) {\n        this.images[this.selectedImageIndex].metadata = metadata;\n        this.imagesSubject.next([...this.images]);\n      } else {\n        console.log(\"Its not possible save metadata\");\n      }\n    }\n    //Methot for merge json metadata with a file\n    embedJsonInImage(imageFile, jsonData) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // Send data to backend and wait response (imagen with metadata)\n          const response = yield firstValueFrom(_this2.apiService.embedInfoInImage(imageFile, jsonData));\n          // Check if response is undefined and valid blob\n          if (!(response instanceof Blob)) {\n            throw new Error('Answer is not valid blob');\n          }\n          // Transform blob to file\n          const modifiedFile = new File([response], imageFile.name, {\n            type: response.type,\n            lastModified: Date.now()\n          });\n          return modifiedFile;\n        } catch (error) {\n          console.error('Error embedding Json in image:', error);\n          throw error;\n        }\n      })();\n    }\n    //Methot for extract json metadata from a file\n    extractMetadataFromImage(image) {\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = event => {\n            try {\n              const arrayBuffer = event.target.result;\n              // Use ExifReader to get metadat\n              const tags = ExifReader.load(arrayBuffer);\n              if (tags && tags['UserComment']) {\n                const userComment = tags['UserComment'].description;\n                try {\n                  const shapes = JSON.parse(userComment);\n                  resolve(shapes);\n                } catch (error) {\n                  reject('Error to transform UserComment to shapes.');\n                }\n              } else {\n                reject('UserComment is not find on metadata from image.');\n              }\n            } catch (error) {\n              console.error('Error processing metadata EXIF:', error);\n              reject('Error processing metadata EXIF.');\n            }\n          };\n          reader.onerror = error => {\n            console.error('Error readding file:', error);\n            reject('Error readding file.');\n          };\n          reader.readAsArrayBuffer(image);\n        });\n      })();\n    }\n    //transform shape to json\n    shapesToJson(shapes) {\n      const json = JSON.stringify(shapes);\n      return json;\n    }\n    //save image withmetada for download\n    saveImageWithMetadata() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (_this3.selectedImageIndex != null) {\n          const imageWithMetadata = _this3.images[_this3.selectedImageIndex];\n          _this3.spinnerService.show();\n          if (imageWithMetadata.metadata) {\n            const jsonMetadata = _this3.shapesToJson(imageWithMetadata.metadata);\n            const imgWithMetadataembed = yield _this3.embedJsonInImage(imageWithMetadata.file, jsonMetadata);\n            _this3.downloadImage(imgWithMetadataembed);\n          } else {\n            //console.log(\"Download imagen without metadata\");\n            _this3.downloadImage(imageWithMetadata.file);\n          }\n          _this3.spinnerService.hide();\n        }\n      })();\n    }\n    //save all images withmetada for download\n    saveAllImagesWithMetadata() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const zip = new JSZip();\n        _this4.spinnerService.show();\n        for (const imageWithMetadata of _this4.images) {\n          try {\n            if (imageWithMetadata.metadata) {\n              const jsonMetadata = _this4.shapesToJson(imageWithMetadata.metadata);\n              const imgWithMetadata = yield _this4.embedJsonInImage(imageWithMetadata.file, jsonMetadata);\n              zip.file(imageWithMetadata.file.name, imgWithMetadata);\n            } else {\n              zip.file(imageWithMetadata.file.name, imageWithMetadata.file);\n            }\n          } catch (error) {\n            console.error(`Error saving image`);\n          }\n        }\n        // Generate and download ZIP file\n        zip.generateAsync({\n          type: 'blob'\n        }).then(content => {\n          saveAs(content, 'images.zip');\n        }).catch(error => {\n          console.error('Error creating ZIP file:', error);\n        });\n        _this4.spinnerService.hide();\n      })();\n    }\n    downloadImage(file) {\n      const link = document.createElement('a');\n      link.href = URL.createObjectURL(file);\n      link.download = file.name;\n      link.click();\n      URL.revokeObjectURL(link.href);\n    }\n    static #_ = this.ɵfac = function ImageService_Factory(t) {\n      return new (t || ImageService)(i0.ɵɵinject(i1.SpinnerService), i0.ɵɵinject(i2.ApiService));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ImageService,\n      factory: ImageService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ImageService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}