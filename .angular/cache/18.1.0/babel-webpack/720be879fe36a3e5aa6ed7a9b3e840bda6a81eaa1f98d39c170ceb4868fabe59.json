{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport { getStringFromDataView, objectAssign } from './utils.js';\nimport XmpTagNames from './xmp-tag-names.js';\nimport DOMParser from './dom-parser.js';\nexport default {\n  read\n};\nfunction read(dataView, chunks) {\n  const tags = {};\n  if (typeof dataView === 'string') {\n    readTags(tags, dataView);\n    return tags;\n  }\n  const [standardXmp, extendedXmp] = extractCompleteChunks(dataView, chunks);\n  const hasStandardTags = readTags(tags, standardXmp);\n  if (extendedXmp) {\n    const hasExtendedTags = readTags(tags, extendedXmp);\n    if (!hasStandardTags && !hasExtendedTags) {\n      // Some writers are not spec-compliant in that they split an XMP\n      // metadata tree over both the standard XMP block and the extended\n      // XMP block. If we failed parsing both of the XMPs in the regular\n      // way, we try to combine them to see if that works better.\n      delete tags._raw;\n      readTags(tags, combineChunks(dataView, chunks));\n    }\n  }\n  return tags;\n}\n\n// The first chunk is always the regular XMP document. Then there is something\n// called extended XMP. The extended XMP is also a single XMP document but it\n// can be divided into multiple chunks that need to be combined into one.\nfunction extractCompleteChunks(dataView, chunks) {\n  if (chunks.length === 0) {\n    return [];\n  }\n  const completeChunks = [combineChunks(dataView, chunks.slice(0, 1))];\n  if (chunks.length > 1) {\n    completeChunks.push(combineChunks(dataView, chunks.slice(1)));\n  }\n  return completeChunks;\n}\nfunction combineChunks(dataView, chunks) {\n  const totalLength = chunks.reduce((size, chunk) => size + chunk.length, 0);\n  const combinedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    const slice = dataView.buffer.slice(chunk.dataOffset, chunk.dataOffset + chunk.length);\n    combinedChunks.set(new Uint8Array(slice), offset);\n    offset += chunk.length;\n  }\n  return new DataView(combinedChunks.buffer);\n}\nfunction readTags(tags, chunkDataView) {\n  try {\n    const {\n      doc,\n      raw\n    } = getDocument(chunkDataView);\n    tags._raw = (tags._raw || '') + raw;\n    const rdf = getRDF(doc);\n    objectAssign(tags, parseXMPObject(convertToObject(rdf, true)));\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getDocument(chunkDataView) {\n  const domParser = DOMParser.get();\n  if (!domParser) {\n    console.warn('Warning: DOMParser is not available. It is needed to be able to parse XMP tags.'); // eslint-disable-line no-console\n    throw new Error();\n  }\n  const xmlString = typeof chunkDataView === 'string' ? chunkDataView : getStringFromDataView(chunkDataView, 0, chunkDataView.byteLength);\n  const doc = domParser.parseFromString(trimXmlSource(xmlString), 'application/xml');\n  if (doc.documentElement.nodeName === 'parsererror') {\n    throw new Error(doc.documentElement.textContent);\n  }\n  return {\n    doc,\n    raw: xmlString\n  };\n}\nfunction trimXmlSource(xmlSource) {\n  return xmlSource.replace(/^.+(<\\?xpacket begin)/, '$1').replace(/(<\\?xpacket end=\".*\"\\?>).+$/, '$1');\n}\nfunction getRDF(node) {\n  for (let i = 0; i < node.childNodes.length; i++) {\n    if (node.childNodes[i].tagName === 'x:xmpmeta') {\n      return getRDF(node.childNodes[i]);\n    }\n    if (node.childNodes[i].tagName === 'rdf:RDF') {\n      return node.childNodes[i];\n    }\n  }\n  throw new Error();\n}\nfunction convertToObject(node, isTopNode = false) {\n  const childNodes = getChildNodes(node);\n  if (hasTextOnlyContent(childNodes)) {\n    if (isTopNode) {\n      return {};\n    }\n    return getTextValue(childNodes[0]);\n  }\n  return getElementsFromNodes(childNodes);\n}\nfunction getChildNodes(node) {\n  const elements = [];\n  for (let i = 0; i < node.childNodes.length; i++) {\n    elements.push(node.childNodes[i]);\n  }\n  return elements;\n}\nfunction hasTextOnlyContent(nodes) {\n  return nodes.length === 1 && nodes[0].nodeName === '#text';\n}\nfunction getTextValue(node) {\n  return node.nodeValue;\n}\nfunction getElementsFromNodes(nodes) {\n  const elements = {};\n  nodes.forEach(node => {\n    if (isElement(node)) {\n      const nodeElement = getElementFromNode(node);\n      if (elements[node.nodeName] !== undefined) {\n        if (!Array.isArray(elements[node.nodeName])) {\n          elements[node.nodeName] = [elements[node.nodeName]];\n        }\n        elements[node.nodeName].push(nodeElement);\n      } else {\n        elements[node.nodeName] = nodeElement;\n      }\n    }\n  });\n  return elements;\n}\nfunction isElement(node) {\n  return node.nodeName && node.nodeName !== '#text';\n}\nfunction getElementFromNode(node) {\n  return {\n    attributes: getAttributes(node),\n    value: convertToObject(node)\n  };\n}\nfunction getAttributes(element) {\n  const attributes = {};\n  for (let i = 0; i < element.attributes.length; i++) {\n    attributes[element.attributes[i].nodeName] = decodeURIComponent(escape(element.attributes[i].value));\n  }\n  return attributes;\n}\nfunction parseXMPObject(xmpObject) {\n  const tags = {};\n  if (typeof xmpObject === 'string') {\n    return xmpObject;\n  }\n  for (const nodeName in xmpObject) {\n    let nodes = xmpObject[nodeName];\n    if (!Array.isArray(nodes)) {\n      nodes = [nodes];\n    }\n    nodes.forEach(node => {\n      objectAssign(tags, parseNodeAttributesAsTags(node.attributes));\n      if (typeof node.value === 'object') {\n        objectAssign(tags, parseNodeChildrenAsTags(node.value));\n      }\n    });\n  }\n  return tags;\n}\nfunction parseNodeAttributesAsTags(attributes) {\n  const tags = {};\n  for (const name in attributes) {\n    try {\n      if (isTagAttribute(name)) {\n        tags[getLocalName(name)] = {\n          value: attributes[name],\n          attributes: {},\n          description: getDescription(attributes[name], name)\n        };\n      }\n    } catch (error) {\n      // Keep going and try to parse the rest of the tags.\n    }\n  }\n  return tags;\n}\nfunction isTagAttribute(name) {\n  return name !== 'rdf:parseType' && !isNamespaceDefinition(name);\n}\nfunction isNamespaceDefinition(name) {\n  return name.split(':')[0] === 'xmlns';\n}\nfunction getLocalName(name) {\n  if (/^MicrosoftPhoto(_\\d+_)?:Rating$/i.test(name)) {\n    return 'RatingPercent';\n  }\n  return name.split(':')[1];\n}\nfunction getDescription(value, name = undefined) {\n  if (Array.isArray(value)) {\n    const arrayDescription = getDescriptionOfArray(value);\n    if (name && typeof XmpTagNames[name] === 'function') {\n      return XmpTagNames[name](value, arrayDescription);\n    }\n    return arrayDescription;\n  }\n  if (typeof value === 'object') {\n    return getDescriptionOfObject(value);\n  }\n  try {\n    if (name && typeof XmpTagNames[name] === 'function') {\n      return XmpTagNames[name](value);\n    }\n    return decodeURIComponent(escape(value));\n  } catch (error) {\n    return value;\n  }\n}\nfunction getDescriptionOfArray(value) {\n  return value.map(item => {\n    if (item.value !== undefined) {\n      return getDescription(item.value);\n    }\n    return getDescription(item);\n  }).join(', ');\n}\nfunction getDescriptionOfObject(value) {\n  const descriptions = [];\n  for (const key in value) {\n    descriptions.push(`${getClearTextKey(key)}: ${getDescription(value[key].value)}`);\n  }\n  return descriptions.join('; ');\n}\nfunction getClearTextKey(key) {\n  if (key === 'CiAdrCity') {\n    return 'CreatorCity';\n  }\n  if (key === 'CiAdrCtry') {\n    return 'CreatorCountry';\n  }\n  if (key === 'CiAdrExtadr') {\n    return 'CreatorAddress';\n  }\n  if (key === 'CiAdrPcode') {\n    return 'CreatorPostalCode';\n  }\n  if (key === 'CiAdrRegion') {\n    return 'CreatorRegion';\n  }\n  if (key === 'CiEmailWork') {\n    return 'CreatorWorkEmail';\n  }\n  if (key === 'CiTelWork') {\n    return 'CreatorWorkPhone';\n  }\n  if (key === 'CiUrlWork') {\n    return 'CreatorWorkUrl';\n  }\n  return key;\n}\nfunction parseNodeChildrenAsTags(children) {\n  const tags = {};\n  for (const name in children) {\n    try {\n      if (!isNamespaceDefinition(name)) {\n        tags[getLocalName(name)] = parseNodeAsTag(children[name], name);\n      }\n    } catch (error) {\n      // Keep going and try to parse the rest of the tags.\n    }\n  }\n  return tags;\n}\nfunction parseNodeAsTag(node, name) {\n  if (isDuplicateTag(node)) {\n    return parseNodeAsDuplicateTag(node, name);\n  }\n  if (isEmptyResourceTag(node)) {\n    return {\n      value: '',\n      attributes: {},\n      description: ''\n    };\n  }\n  if (hasNestedSimpleRdfDescription(node)) {\n    return parseNodeAsSimpleRdfDescription(node, name);\n  }\n  if (hasNestedStructureRdfDescription(node)) {\n    return parseNodeAsStructureRdfDescription(node, name);\n  }\n  if (isCompactStructure(node)) {\n    return parseNodeAsCompactStructure(node, name);\n  }\n  if (isArray(node)) {\n    return parseNodeAsArray(node, name);\n  }\n  return parseNodeAsSimpleValue(node, name);\n}\nfunction isEmptyResourceTag(node) {\n  return node.attributes['rdf:parseType'] === 'Resource' && typeof node.value === 'string' && node.value.trim() === '';\n}\nfunction isDuplicateTag(node) {\n  return Array.isArray(node);\n}\nfunction parseNodeAsDuplicateTag(node, name) {\n  return parseNodeAsSimpleValue(node[node.length - 1], name);\n}\nfunction hasNestedSimpleRdfDescription(node) {\n  return node.attributes['rdf:parseType'] === 'Resource' && node.value['rdf:value'] !== undefined || node.value['rdf:Description'] !== undefined && node.value['rdf:Description'].value['rdf:value'] !== undefined;\n}\nfunction parseNodeAsSimpleRdfDescription(node, name) {\n  const attributes = parseNodeAttributes(node);\n  if (node.value['rdf:Description'] !== undefined) {\n    node = node.value['rdf:Description'];\n  }\n  objectAssign(attributes, parseNodeAttributes(node), parseNodeChildrenAsAttributes(node));\n  const value = parseRdfValue(node);\n  return {\n    value,\n    attributes,\n    description: getDescription(value, name)\n  };\n}\nfunction parseNodeAttributes(node) {\n  const attributes = {};\n  for (const name in node.attributes) {\n    if (name !== 'rdf:parseType' && name !== 'rdf:resource' && !isNamespaceDefinition(name)) {\n      attributes[getLocalName(name)] = node.attributes[name];\n    }\n  }\n  return attributes;\n}\nfunction parseNodeChildrenAsAttributes(node) {\n  const attributes = {};\n  for (const name in node.value) {\n    if (name !== 'rdf:value' && !isNamespaceDefinition(name)) {\n      attributes[getLocalName(name)] = node.value[name].value;\n    }\n  }\n  return attributes;\n}\nfunction parseRdfValue(node) {\n  return getURIValue(node.value['rdf:value']) || node.value['rdf:value'].value;\n}\nfunction hasNestedStructureRdfDescription(node) {\n  return node.attributes['rdf:parseType'] === 'Resource' || node.value['rdf:Description'] !== undefined && node.value['rdf:Description'].value['rdf:value'] === undefined;\n}\nfunction parseNodeAsStructureRdfDescription(node, name) {\n  const tag = {\n    value: {},\n    attributes: {}\n  };\n  if (node.value['rdf:Description'] !== undefined) {\n    objectAssign(tag.value, parseNodeAttributesAsTags(node.value['rdf:Description'].attributes));\n    objectAssign(tag.attributes, parseNodeAttributes(node));\n    node = node.value['rdf:Description'];\n  }\n  objectAssign(tag.value, parseNodeChildrenAsTags(node.value));\n  tag.description = getDescription(tag.value, name);\n  return tag;\n}\nfunction isCompactStructure(node) {\n  return Object.keys(node.value).length === 0 && node.attributes['xml:lang'] === undefined && node.attributes['rdf:resource'] === undefined;\n}\nfunction parseNodeAsCompactStructure(node, name) {\n  const value = parseNodeAttributesAsTags(node.attributes);\n  return {\n    value,\n    attributes: {},\n    description: getDescription(value, name)\n  };\n}\nfunction isArray(node) {\n  return getArrayChild(node.value) !== undefined;\n}\nfunction getArrayChild(value) {\n  return value['rdf:Bag'] || value['rdf:Seq'] || value['rdf:Alt'];\n}\nfunction parseNodeAsArray(node, name) {\n  let items = getArrayChild(node.value).value['rdf:li'];\n  const attributes = parseNodeAttributes(node);\n  const value = [];\n  if (items === undefined) {\n    items = [];\n  } else if (!Array.isArray(items)) {\n    items = [items];\n  }\n  items.forEach(item => {\n    value.push(parseArrayValue(item));\n  });\n  return {\n    value,\n    attributes,\n    description: getDescription(value, name)\n  };\n}\nfunction parseArrayValue(item) {\n  if (hasNestedSimpleRdfDescription(item)) {\n    return parseNodeAsSimpleRdfDescription(item);\n  }\n  if (hasNestedStructureRdfDescription(item)) {\n    return parseNodeAsStructureRdfDescription(item).value;\n  }\n  if (isCompactStructure(item)) {\n    return parseNodeAsCompactStructure(item).value;\n  }\n  return parseNodeAsSimpleValue(item);\n}\nfunction parseNodeAsSimpleValue(node, name) {\n  const value = getURIValue(node) || parseXMPObject(node.value);\n  return {\n    value,\n    attributes: parseNodeAttributes(node),\n    description: getDescription(value, name)\n  };\n}\nfunction getURIValue(node) {\n  return node.attributes && node.attributes['rdf:resource'];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}