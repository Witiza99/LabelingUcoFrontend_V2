{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport IptcTagNames from './iptc-tag-names.js';\nimport TagDecoder from './tag-decoder.js';\nconst BYTES_8BIM = 0x3842494d;\nconst BYTES_8BIM_SIZE = 4;\nconst RESOURCE_BLOCK_HEADER_SIZE = BYTES_8BIM_SIZE + 8;\nconst NAA_RESOURCE_BLOCK_TYPE = 0x0404;\nconst TAG_HEADER_SIZE = 5;\nexport default {\n  read\n};\nfunction read(dataView, dataOffset, includeUnknown) {\n  try {\n    if (Array.isArray(dataView)) {\n      return parseTags(new DataView(Uint8Array.from(dataView).buffer), {\n        size: dataView.length\n      }, 0, includeUnknown);\n    }\n    const {\n      naaBlock,\n      dataOffset: newDataOffset\n    } = getNaaResourceBlock(dataView, dataOffset);\n    return parseTags(dataView, naaBlock, newDataOffset, includeUnknown);\n  } catch (error) {\n    return {};\n  }\n}\nfunction getNaaResourceBlock(dataView, dataOffset) {\n  while (dataOffset + RESOURCE_BLOCK_HEADER_SIZE <= dataView.byteLength) {\n    const resourceBlock = getResourceBlock(dataView, dataOffset);\n    if (isNaaResourceBlock(resourceBlock)) {\n      return {\n        naaBlock: resourceBlock,\n        dataOffset: dataOffset + RESOURCE_BLOCK_HEADER_SIZE\n      };\n    }\n    dataOffset += RESOURCE_BLOCK_HEADER_SIZE + resourceBlock.size + getBlockPadding(resourceBlock);\n  }\n  throw new Error('No IPTC NAA resource block.');\n}\nfunction getResourceBlock(dataView, dataOffset) {\n  const RESOURCE_BLOCK_SIZE_OFFSET = 10;\n  if (dataView.getUint32(dataOffset, false) !== BYTES_8BIM) {\n    throw new Error('Not an IPTC resource block.');\n  }\n  return {\n    type: dataView.getUint16(dataOffset + BYTES_8BIM_SIZE),\n    size: dataView.getUint16(dataOffset + RESOURCE_BLOCK_SIZE_OFFSET)\n  };\n}\nfunction isNaaResourceBlock(resourceBlock) {\n  return resourceBlock.type === NAA_RESOURCE_BLOCK_TYPE;\n}\nfunction getBlockPadding(resourceBlock) {\n  if (resourceBlock.size % 2 !== 0) {\n    return 1;\n  }\n  return 0;\n}\nfunction parseTags(dataView, naaBlock, dataOffset, includeUnknown) {\n  const tags = {};\n  let encoding = undefined;\n  const endOfBlockOffset = dataOffset + naaBlock['size'];\n  while (dataOffset < endOfBlockOffset && dataOffset < dataView.byteLength) {\n    const {\n      tag,\n      tagSize\n    } = readTag(dataView, dataOffset, tags, encoding, includeUnknown);\n    if (tag === null) {\n      break;\n    }\n    if (tag) {\n      if ('encoding' in tag) {\n        encoding = tag.encoding;\n      }\n      if (tags[tag.name] === undefined || tag['repeatable'] === undefined) {\n        tags[tag.name] = {\n          id: tag.id,\n          value: tag.value,\n          description: tag.description\n        };\n      } else {\n        if (!(tags[tag.name] instanceof Array)) {\n          tags[tag.name] = [{\n            id: tags[tag.name].id,\n            value: tags[tag.name].value,\n            description: tags[tag.name].description\n          }];\n        }\n        tags[tag.name].push({\n          id: tag.id,\n          value: tag.value,\n          description: tag.description\n        });\n      }\n    }\n    dataOffset += TAG_HEADER_SIZE + tagSize;\n  }\n  return tags;\n}\nfunction readTag(dataView, dataOffset, tags, encoding, includeUnknown) {\n  const TAG_CODE_OFFSET = 1;\n  const TAG_SIZE_OFFSET = 3;\n  if (leadByteIsMissing(dataView, dataOffset)) {\n    return {\n      tag: null,\n      tagSize: 0\n    };\n  }\n  const tagCode = dataView.getUint16(dataOffset + TAG_CODE_OFFSET);\n  const tagSize = dataView.getUint16(dataOffset + TAG_SIZE_OFFSET);\n  if (!includeUnknown && !IptcTagNames['iptc'][tagCode]) {\n    return {\n      tag: undefined,\n      tagSize\n    };\n  }\n  const tagValue = getTagValue(dataView, dataOffset + TAG_HEADER_SIZE, tagSize);\n  const tag = {\n    id: tagCode,\n    name: getTagName(IptcTagNames['iptc'][tagCode], tagCode, tagValue),\n    value: tagValue,\n    description: getTagDescription(IptcTagNames['iptc'][tagCode], tagValue, tags, encoding)\n  };\n  if (tagIsRepeatable(tagCode)) {\n    tag['repeatable'] = true;\n  }\n  if (tagContainsEncoding(tagCode)) {\n    tag['encoding'] = IptcTagNames['iptc'][tagCode]['encoding_name'](tagValue);\n  }\n  return {\n    tag,\n    tagSize\n  };\n}\nfunction leadByteIsMissing(dataView, dataOffset) {\n  const TAG_LEAD_BYTE = 0x1c;\n  return dataView.getUint8(dataOffset) !== TAG_LEAD_BYTE;\n}\nfunction getTagValue(dataView, offset, size) {\n  const value = [];\n  for (let valueIndex = 0; valueIndex < size; valueIndex++) {\n    value.push(dataView.getUint8(offset + valueIndex));\n  }\n  return value;\n}\nfunction getTagName(tag, tagCode, tagValue) {\n  if (!tag) {\n    return `undefined-${tagCode}`;\n  }\n  if (tagIsName(tag)) {\n    return tag;\n  }\n  if (hasDynamicName(tag)) {\n    return tag['name'](tagValue);\n  }\n  return tag['name'];\n}\nfunction tagIsName(tag) {\n  return typeof tag === 'string';\n}\nfunction hasDynamicName(tag) {\n  return typeof tag['name'] === 'function';\n}\nfunction getTagDescription(tag, tagValue, tags, encoding) {\n  if (hasDescriptionProperty(tag)) {\n    try {\n      return tag['description'](tagValue, tags);\n    } catch (error) {\n      // Fall through to next handler.\n    }\n  }\n  if (tagValueIsText(tag, tagValue)) {\n    return TagDecoder.decode(encoding, tagValue);\n  }\n  return tagValue;\n}\nfunction tagValueIsText(tag, tagValue) {\n  return tag && tagValue instanceof Array;\n}\nfunction hasDescriptionProperty(tag) {\n  return tag && tag['description'] !== undefined;\n}\nfunction tagIsRepeatable(tagCode) {\n  return IptcTagNames['iptc'][tagCode] && IptcTagNames['iptc'][tagCode]['repeatable'];\n}\nfunction tagContainsEncoding(tagCode) {\n  return IptcTagNames['iptc'][tagCode] && IptcTagNames['iptc'][tagCode]['encoding_name'] !== undefined;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}