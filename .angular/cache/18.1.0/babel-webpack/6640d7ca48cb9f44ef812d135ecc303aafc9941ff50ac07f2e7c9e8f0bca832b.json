{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport DataViewWrapper from './dataview.js';\nexport function getDataView(data, byteOffset, byteLength) {\n  try {\n    return new DataView(data, byteOffset, byteLength);\n  } catch (error) {\n    return new DataViewWrapper(data, byteOffset, byteLength);\n  }\n}\nexport function getStringFromDataView(dataView, offset, length) {\n  const chars = [];\n  for (let i = 0; i < length && offset + i < dataView.byteLength; i++) {\n    chars.push(dataView.getUint8(offset + i));\n  }\n  return getStringValueFromArray(chars);\n}\nexport function getNullTerminatedStringFromDataView(dataView, offset) {\n  const chars = [];\n  let i = 0;\n  while (offset + i < dataView.byteLength) {\n    const char = dataView.getUint8(offset + i);\n    if (char === 0) {\n      break;\n    }\n    chars.push(char);\n    i++;\n  }\n  return getStringValueFromArray(chars);\n}\nexport function getUnicodeStringFromDataView(dataView, offset, length) {\n  const chars = [];\n  for (let i = 0; i < length && offset + i < dataView.byteLength; i += 2) {\n    chars.push(dataView.getUint16(offset + i));\n  }\n  if (chars[chars.length - 1] === 0) {\n    chars.pop();\n  }\n  return getStringValueFromArray(chars);\n}\nexport function getPascalStringFromDataView(dataView, offset) {\n  const size = dataView.getUint8(offset);\n  const string = getStringFromDataView(dataView, offset + 1, size);\n  return [size, string];\n}\nexport function getStringValueFromArray(charArray) {\n  return charArray.map(charCode => String.fromCharCode(charCode)).join('');\n}\nexport function getCharacterArray(string) {\n  return string.split('').map(character => character.charCodeAt(0));\n}\nexport function objectAssign() {\n  for (let i = 1; i < arguments.length; i++) {\n    for (const property in arguments[i]) {\n      arguments[0][property] = arguments[i][property];\n    }\n  }\n  return arguments[0];\n}\nexport function deferInit(object, key, initializer) {\n  let initialized = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!initialized) {\n        initialized = true;\n        Object.defineProperty(object, key, {\n          configurable: true,\n          enumerable: true,\n          value: initializer.apply(object),\n          writable: true\n        });\n      }\n      return object[key];\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\nexport function getBase64Image(image) {\n  if (typeof btoa !== 'undefined') {\n    if (typeof image === 'string') {\n      // This only happens during the build tests using Node 16+ (npm run test:build).\n      return btoa(image);\n    }\n    // IE11- does not implement reduce on the Uint8Array prototype.\n    return btoa(Array.prototype.reduce.call(new Uint8Array(image), (data, byte) => data + String.fromCharCode(byte), ''));\n  }\n  if (typeof Buffer === 'undefined') {\n    return undefined;\n  }\n  if (typeof Buffer.from !== 'undefined') {\n    // eslint-disable-line no-undef\n    return Buffer.from(image).toString('base64'); // eslint-disable-line no-undef\n  }\n  return new Buffer(image).toString('base64'); // eslint-disable-line no-undef\n}\nexport function dataUriToBuffer(dataUri) {\n  const data = dataUri.substring(dataUri.indexOf(',') + 1);\n  if (dataUri.indexOf(';base64') !== -1) {\n    if (typeof atob !== 'undefined') {\n      return Uint8Array.from(atob(data), char => char.charCodeAt(0)).buffer;\n    }\n    if (typeof Buffer === 'undefined') {\n      return undefined;\n    }\n    if (typeof Buffer.from !== 'undefined') {\n      // eslint-disable-line no-undef\n      return Buffer.from(data, 'base64'); // eslint-disable-line no-undef\n    }\n    return new Buffer(data, 'base64'); // eslint-disable-line no-undef\n  }\n  const decodedData = decodeURIComponent(data);\n  if (typeof Buffer !== 'undefined') {\n    if (typeof Buffer.from !== 'undefined') {\n      // eslint-disable-line no-undef\n      return Buffer.from(decodedData); // eslint-disable-line no-undef\n    }\n    return new Buffer(decodedData); // eslint-disable-line no-undef\n  }\n  return Uint8Array.from(decodedData, char => char.charCodeAt(0)).buffer;\n}\nexport function padStart(string, length, character) {\n  const padding = strRepeat(character, length - string.length);\n  return padding + string;\n}\nexport function parseFloatRadix(string, radix) {\n  return parseInt(string.replace('.', ''), radix) / Math.pow(radix, (string.split('.')[1] || '').length);\n}\nexport function strRepeat(string, num) {\n  return new Array(num + 1).join(string);\n}\nexport const COMPRESSION_METHOD_NONE = undefined;\nexport const COMPRESSION_METHOD_DEFLATE = 0;\nexport function decompress(dataView, compressionMethod, encoding, returnType = 'string') {\n  if (compressionMethod === COMPRESSION_METHOD_DEFLATE) {\n    if (typeof DecompressionStream === 'function') {\n      const decompressionStream = new DecompressionStream('deflate');\n      const decompressedStream = new Blob([dataView]).stream().pipeThrough(decompressionStream);\n      if (returnType === 'dataview') {\n        return new Response(decompressedStream).arrayBuffer().then(arrayBuffer => new DataView(arrayBuffer));\n      }\n      return new Response(decompressedStream).arrayBuffer().then(buffer => new TextDecoder(encoding).decode(buffer));\n    }\n  }\n  if (compressionMethod !== undefined) {\n    return Promise.reject(`Unknown compression method ${compressionMethod}.`);\n  }\n  return dataView;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}