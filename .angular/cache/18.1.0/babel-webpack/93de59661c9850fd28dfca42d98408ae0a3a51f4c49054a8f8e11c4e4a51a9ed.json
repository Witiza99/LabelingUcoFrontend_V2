{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Constants from './constants.js';\nimport Types from './types.js';\nimport TagNames, { IFD_TYPE_0TH, IFD_TYPE_1ST } from './tag-names.js';\nconst getTagValueAt = {\n  1: Types.getByteAt,\n  2: Types.getAsciiAt,\n  3: Types.getShortAt,\n  4: Types.getLongAt,\n  5: Types.getRationalAt,\n  7: Types.getUndefinedAt,\n  9: Types.getSlongAt,\n  10: Types.getSrationalAt,\n  13: Types.getIfdPointerAt\n};\nexport function get0thIfdOffset(dataView, tiffHeaderOffset, byteOrder) {\n  return tiffHeaderOffset + Types.getLongAt(dataView, tiffHeaderOffset + 4, byteOrder);\n}\nexport function readIfd(dataView, ifdType, tiffHeaderOffset, offset, byteOrder, includeUnknown) {\n  const FIELD_COUNT_SIZE = Types.getTypeSize('SHORT');\n  const FIELD_SIZE = 12;\n  const tags = {};\n  const numberOfFields = getNumberOfFields(dataView, offset, byteOrder);\n  offset += FIELD_COUNT_SIZE;\n  for (let fieldIndex = 0; fieldIndex < numberOfFields; fieldIndex++) {\n    if (offset + FIELD_SIZE > dataView.byteLength) {\n      break;\n    }\n    const tag = readTag(dataView, ifdType, tiffHeaderOffset, offset, byteOrder, includeUnknown);\n    if (tag !== undefined) {\n      tags[tag.name] = {\n        'id': tag.id,\n        'value': tag.value,\n        'description': tag.description\n      };\n    }\n    offset += FIELD_SIZE;\n  }\n  if (Constants.USE_THUMBNAIL && offset < dataView.byteLength - Types.getTypeSize('LONG')) {\n    const nextIfdOffset = Types.getLongAt(dataView, offset, byteOrder);\n    if (nextIfdOffset !== 0 && ifdType === IFD_TYPE_0TH) {\n      tags['Thumbnail'] = readIfd(dataView, IFD_TYPE_1ST, tiffHeaderOffset, tiffHeaderOffset + nextIfdOffset, byteOrder, true);\n    }\n  }\n  return tags;\n}\nfunction getNumberOfFields(dataView, offset, byteOrder) {\n  if (offset + Types.getTypeSize('SHORT') <= dataView.byteLength) {\n    return Types.getShortAt(dataView, offset, byteOrder);\n  }\n  return 0;\n}\nfunction readTag(dataView, ifdType, tiffHeaderOffset, offset, byteOrder, includeUnknown) {\n  const TAG_CODE_IPTC_NAA = 0x83bb;\n  const TAG_TYPE_OFFSET = Types.getTypeSize('SHORT');\n  const TAG_COUNT_OFFSET = TAG_TYPE_OFFSET + Types.getTypeSize('SHORT');\n  const TAG_VALUE_OFFSET = TAG_COUNT_OFFSET + Types.getTypeSize('LONG');\n  const tagCode = Types.getShortAt(dataView, offset, byteOrder);\n  const tagType = Types.getShortAt(dataView, offset + TAG_TYPE_OFFSET, byteOrder);\n  const tagCount = Types.getLongAt(dataView, offset + TAG_COUNT_OFFSET, byteOrder);\n  let tagValue;\n  if (Types.typeSizes[tagType] === undefined || !includeUnknown && TagNames[ifdType][tagCode] === undefined) {\n    return undefined;\n  }\n  if (tagValueFitsInOffsetSlot(tagType, tagCount)) {\n    tagValue = getTagValue(dataView, offset + TAG_VALUE_OFFSET, tagType, tagCount, byteOrder);\n  } else {\n    const tagValueOffset = Types.getLongAt(dataView, offset + TAG_VALUE_OFFSET, byteOrder);\n    if (tagValueFitsInDataView(dataView, tiffHeaderOffset, tagValueOffset, tagType, tagCount)) {\n      const forceByteType = tagCode === TAG_CODE_IPTC_NAA;\n      tagValue = getTagValue(dataView, tiffHeaderOffset + tagValueOffset, tagType, tagCount, byteOrder, forceByteType);\n    } else {\n      tagValue = '<faulty value>';\n    }\n  }\n  if (tagType === Types.tagTypes['ASCII']) {\n    tagValue = splitNullSeparatedAsciiString(tagValue);\n    tagValue = decodeAsciiValue(tagValue);\n  }\n  let tagName = `undefined-${tagCode}`;\n  let tagDescription = tagValue;\n  if (TagNames[ifdType][tagCode] !== undefined) {\n    if (TagNames[ifdType][tagCode]['name'] !== undefined && TagNames[ifdType][tagCode]['description'] !== undefined) {\n      tagName = TagNames[ifdType][tagCode]['name'];\n      try {\n        tagDescription = TagNames[ifdType][tagCode]['description'](tagValue);\n      } catch (error) {\n        tagDescription = getDescriptionFromTagValue(tagValue);\n      }\n    } else if (tagType === Types.tagTypes['RATIONAL'] || tagType === Types.tagTypes['SRATIONAL']) {\n      tagName = TagNames[ifdType][tagCode];\n      tagDescription = '' + tagValue[0] / tagValue[1];\n    } else {\n      tagName = TagNames[ifdType][tagCode];\n      tagDescription = getDescriptionFromTagValue(tagValue);\n    }\n  }\n  return {\n    id: tagCode,\n    name: tagName,\n    value: tagValue,\n    description: tagDescription\n  };\n}\nfunction tagValueFitsInOffsetSlot(tagType, tagCount) {\n  return Types.typeSizes[tagType] * tagCount <= Types.getTypeSize('LONG');\n}\nfunction getTagValue(dataView, offset, type, count, byteOrder, forceByteType = false) {\n  let value = [];\n  if (forceByteType) {\n    count = count * Types.typeSizes[type];\n    type = Types.tagTypes['BYTE'];\n  }\n  for (let valueIndex = 0; valueIndex < count; valueIndex++) {\n    value.push(getTagValueAt[type](dataView, offset, byteOrder));\n    offset += Types.typeSizes[type];\n  }\n  if (type === Types.tagTypes['ASCII']) {\n    value = Types.getAsciiValue(value);\n  } else if (value.length === 1) {\n    value = value[0];\n  }\n  return value;\n}\nfunction tagValueFitsInDataView(dataView, tiffHeaderOffset, tagValueOffset, tagType, tagCount) {\n  return tiffHeaderOffset + tagValueOffset + Types.typeSizes[tagType] * tagCount <= dataView.byteLength;\n}\nfunction splitNullSeparatedAsciiString(string) {\n  const tagValue = [];\n  let i = 0;\n  for (let j = 0; j < string.length; j++) {\n    if (string[j] === '\\x00') {\n      i++;\n      continue;\n    }\n    if (tagValue[i] === undefined) {\n      tagValue[i] = '';\n    }\n    tagValue[i] += string[j];\n  }\n  return tagValue;\n}\nfunction decodeAsciiValue(asciiValue) {\n  try {\n    return asciiValue.map(value => decodeURIComponent(escape(value)));\n  } catch (error) {\n    return asciiValue;\n  }\n}\nfunction getDescriptionFromTagValue(tagValue) {\n  if (tagValue instanceof Array) {\n    return tagValue.join(', ');\n  }\n  return tagValue;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}