{"ast":null,"code":"import Constants from './constants.js';\nimport { getNullTerminatedStringFromDataView, getStringFromDataView } from './utils.js';\n// import {get64BitValue} from './image-header-iso-bmff-utils.js';\nimport { parseItemLocationBox } from './image-header-iso-bmff-iloc.js';\n\n// HEIC and AVIF files are based on the ISO-BMFF format. This file format is\n// built up by boxes. There are boxes and full boxes. All box types have a\n// length (4 or 8 bytes) and a type (4 bytes). Full boxes also have a version\n// (1 byte) and flags (3 bytes). The boxes can be nested. Each box type has its\n// own structure that can be seen in the specification.\n//\n// For metadata we are interested in the meta box. The meta box contains sub\n// boxes. The sub box type iinf has info about which types of metadata are\n// present in the file. The item ID we get from there we then look up in the\n// iloc sub box to get the offset to the real location of the metadata.\n//\n// The ICC profiles is a bit more nested. We have to look in\n// meta > iprp > ipco > colr, and then the whole profile is stored there.\n\n// These are actually 32-bit strings, not random IDs, e.g. \"ftyp\" and \"meta\".\nconst TYPE_FTYP = 0x66747970;\nconst TYPE_IPRP = 0x69707270;\nconst TYPE_META = 0x6d657461;\nconst TYPE_ILOC = 0x696c6f63;\nconst TYPE_IINF = 0x69696e66;\nconst TYPE_INFE = 0x696e6665;\nconst TYPE_IPCO = 0x6970636f;\nconst TYPE_COLR = 0x636f6c72;\n\n// const EXTENSION_TYPE_FDEL = 0x6664656c;\n\nexport const ITEM_INFO_TYPE_EXIF = 0x45786966;\nexport const ITEM_INFO_TYPE_MIME = 0x6d696d65;\nconst ITEM_INFO_TYPE_URI = 0x75726920;\n\n/**\n * Parses a ISO-BMFF box from the provided data view starting at the given offset.\n *\n * @param {DataView} dataView - The DataView to parse.\n * @param {number} offset - The offset at which to start parsing.\n * @returns {Object} The parsed box.\n */\nexport function parseBox(dataView, offset) {\n  const BOX_TYPE_OFFSET = 4;\n  const BOX_MIN_LENGTH = 8;\n  const VERSION_SIZE = 1;\n  const {\n    length,\n    contentOffset\n  } = getBoxLength(dataView, offset);\n  if (length < BOX_MIN_LENGTH) {\n    return undefined;\n  }\n  const type = dataView.getUint32(offset + BOX_TYPE_OFFSET);\n  if (type === TYPE_FTYP) {\n    return parseFileTypeBox(dataView, contentOffset, length);\n  }\n  if (type === TYPE_IPRP) {\n    return parseItemPropertiesBox(dataView, offset, contentOffset, length);\n  }\n  if (type === TYPE_IPCO) {\n    return parseItemPropertyContainerBox(dataView, offset, contentOffset, length);\n  }\n  if (type === TYPE_COLR) {\n    return parseColorInformationBox(dataView, contentOffset, length);\n  }\n\n  // The following are full boxes, also containing version and flags.\n  const version = dataView.getUint8(contentOffset);\n  if (type === TYPE_META) {\n    return parseMetadataBox(dataView, offset, contentOffset + VERSION_SIZE, length);\n  }\n  if (type === TYPE_ILOC) {\n    return parseItemLocationBox(dataView, version, contentOffset + VERSION_SIZE, length);\n  }\n  if (type === TYPE_IINF) {\n    return parseItemInformationBox(dataView, offset, version, contentOffset + VERSION_SIZE, length);\n  }\n  if (type === TYPE_INFE) {\n    return parseItemInformationEntryBox(dataView, offset, version, contentOffset + VERSION_SIZE, length);\n  }\n  return {\n    // type: getStringFromDataView(dataView, offset + BOX_TYPE_OFFSET, 4),\n    type: undefined,\n    length\n  };\n}\n\n/**\n * @typedef {Object} BoxLength\n * @property {number} length The length of the box including length and type.\n * @property {number} contentOffset\n */\n\n/**\n * @param {DataView} dataView\n * @param {number} offset\n * @returns {BoxLength}\n */\nfunction getBoxLength(dataView, offset) {\n  const BOX_LENGTH_SIZE = 4;\n  const BOX_TYPE_SIZE = 4;\n  const BOX_EXTENDED_SIZE = 8;\n  const BOX_EXTENDED_SIZE_LOW_OFFSET = 12;\n  const boxLength = dataView.getUint32(offset);\n  if (extendsToEndOfFile(boxLength)) {\n    return {\n      length: dataView.byteLength - offset,\n      contentOffset: offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE\n    };\n  }\n  if (hasExtendedSize(boxLength)) {\n    if (hasEmptyHighBits(dataView, offset)) {\n      // It's a bit tricky to handle 64 bit numbers in JavaScript. Let's\n      // wait until there are real-world examples where it is necessary.\n      return {\n        length: dataView.getUint32(offset + BOX_EXTENDED_SIZE_LOW_OFFSET),\n        contentOffset: offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE + BOX_EXTENDED_SIZE\n      };\n    }\n  }\n  return {\n    length: boxLength,\n    contentOffset: offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE\n  };\n}\nfunction extendsToEndOfFile(boxLength) {\n  return boxLength === 0;\n}\nfunction hasExtendedSize(boxLength) {\n  return boxLength === 1;\n}\nfunction hasEmptyHighBits(dataView, offset) {\n  const BOX_EXTENDED_SIZE_OFFSET = 8;\n  return dataView.getUint32(offset + BOX_EXTENDED_SIZE_OFFSET) === 0;\n}\n\n/**\n * @typedef {Object} Offsets\n * @property {number} tiffHeaderOffset\n * @property {Array<Object>} xmpChunks\n * @property {Array<Object>} iccChunks\n * @property {boolean} hasAppMarkers\n */\n\n/**\n * Finds the offsets of ISO-BMFF-structued data in the provided data view.\n *\n * @param {DataView} dataView - The data view to find offsets in.\n * @returns {Offsets} An object containing the offsets of the TIFF header, XMP chunks, ICC chunks, and a boolean indicating if any of these exist.\n */\nexport function findOffsets(dataView) {\n  if (Constants.USE_EXIF || Constants.USE_XMP || Constants.USE_ICC) {\n    const offsets = {};\n    const metaBox = findMetaBox(dataView);\n    if (!metaBox) {\n      return {\n        hasAppMarkers: false\n      };\n    }\n    if (Constants.USE_EXIF) {\n      offsets.tiffHeaderOffset = findExifOffset(dataView, metaBox);\n    }\n    if (Constants.USE_XMP) {\n      offsets.xmpChunks = findXmpChunks(metaBox);\n    }\n    if (Constants.USE_ICC) {\n      offsets.iccChunks = findIccChunks(metaBox);\n    }\n    offsets.hasAppMarkers = offsets.tiffHeaderOffset !== undefined || offsets.xmpChunks !== undefined || offsets.iccChunks !== undefined;\n    return offsets;\n  }\n  return {};\n}\nfunction findMetaBox(dataView) {\n  const BOX_LENGTH_SIZE = 4;\n  const BOX_TYPE_SIZE = 4;\n  let offset = 0;\n  while (offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE <= dataView.byteLength) {\n    const box = parseBox(dataView, offset);\n    if (box === undefined) {\n      break;\n    }\n    if (box.type === 'meta') {\n      return box;\n    }\n    offset += box.length;\n  }\n  return undefined;\n}\nfunction findExifOffset(dataView, metaBox) {\n  try {\n    const exifItemId = findIinfExifItemId(metaBox).itemId;\n    const ilocItem = findIlocItem(metaBox, exifItemId);\n    const exifOffset = ilocItem.baseOffset + ilocItem.extents[0].extentOffset;\n    return getTiffHeaderOffset(dataView, exifOffset);\n  } catch (error) {\n    return undefined;\n  }\n}\nfunction findIinfExifItemId(metaBox) {\n  return metaBox.subBoxes.find(box => box.type === 'iinf').itemInfos.find(itemInfo => itemInfo.itemType === ITEM_INFO_TYPE_EXIF);\n}\nfunction findIlocItem(metaBox, itemId) {\n  return metaBox.subBoxes.find(box => box.type === 'iloc').items.find(item => item.itemId === itemId);\n}\nfunction getTiffHeaderOffset(dataView, exifOffset) {\n  // ISO-BMFF formatted files store the Exif data as an \"Exif block\" where the\n  // first 32 bits is the TIFF header offset.\n  const TIFF_HEADER_OFFSET_SIZE = 4;\n  return exifOffset + TIFF_HEADER_OFFSET_SIZE + dataView.getUint32(exifOffset);\n}\nfunction findXmpChunks(metaBox) {\n  try {\n    const xmpItemId = findIinfXmpItemId(metaBox).itemId;\n    const ilocItem = findIlocItem(metaBox, xmpItemId);\n    const ilocItemExtent = findIlocItem(metaBox, xmpItemId).extents[0];\n    return [{\n      dataOffset: ilocItem.baseOffset + ilocItemExtent.extentOffset,\n      length: ilocItemExtent.extentLength\n    }];\n  } catch (error) {\n    return undefined;\n  }\n}\nfunction findIinfXmpItemId(metaBox) {\n  return metaBox.subBoxes.find(box => box.type === 'iinf').itemInfos.find(itemInfo => itemInfo.itemType === ITEM_INFO_TYPE_MIME && itemInfo.contentType === 'application/rdf+xml');\n}\nfunction findIccChunks(metaBox) {\n  // This finds the first ICC chunk, but there could be one for each image\n  // that is embedded in the file. If it turns out we need to match the ICC\n  // chunk to a specific image, we need to check the \"ipma\" in addition to the\n  // \"ipco\" (currently we only extract the \"ipco\" so more code would be\n  // needed).\n  try {\n    const icc = metaBox.subBoxes.find(box => box.type === 'iprp').subBoxes.find(box => box.type === 'ipco').properties.find(box => box.type === 'colr').icc;\n    if (icc) {\n      return [icc];\n    }\n  } catch (error) {\n    // Let it pass through.\n  }\n  return undefined;\n}\nfunction parseFileTypeBox(dataView, contentOffset, boxLength) {\n  const MAJOR_BRAND_SIZE = 4;\n  const majorBrand = getStringFromDataView(dataView, contentOffset, MAJOR_BRAND_SIZE);\n  return {\n    type: 'ftyp',\n    majorBrand,\n    length: boxLength\n  };\n}\nfunction parseItemPropertiesBox(dataView, startOffset, contentOffset, length) {\n  return {\n    type: 'iprp',\n    subBoxes: parseSubBoxes(dataView, contentOffset, length - (contentOffset - startOffset)),\n    length\n  };\n}\nfunction parseItemPropertyContainerBox(dataView, startOffset, contentOffset, length) {\n  return {\n    type: 'ipco',\n    properties: parseSubBoxes(dataView, contentOffset, length - (contentOffset - startOffset)),\n    length\n  };\n}\nfunction parseColorInformationBox(dataView, contentOffset, length) {\n  return {\n    type: 'colr',\n    icc: parseIcc(dataView, contentOffset),\n    length\n  };\n}\nfunction parseIcc(dataView, contentOffset) {\n  const COLOR_TYPE_SIZE = 4;\n  const colorType = getStringFromDataView(dataView, contentOffset, COLOR_TYPE_SIZE);\n  if (colorType !== 'prof' && colorType !== 'rICC') {\n    // Support for nclx would require some restructuring for ICC handling.\n    // Probably do it as a separate feature instead of combining with ICC.\n    // Exiftool groups it under QuickTime. The test file test.avif has nclx.\n    return undefined;\n  }\n  return {\n    offset: contentOffset + COLOR_TYPE_SIZE,\n    length: dataView.getUint32(contentOffset + COLOR_TYPE_SIZE),\n    chunkNumber: 1,\n    chunksTotal: 1\n  };\n}\nfunction parseMetadataBox(dataView, startOffset, contentOffset, length) {\n  const FLAGS_SIZE = 3;\n  return {\n    type: 'meta',\n    subBoxes: parseSubBoxes(dataView, contentOffset + FLAGS_SIZE, length - (contentOffset + FLAGS_SIZE - startOffset)),\n    length\n  };\n}\n\n/**\n * @param {DataView} dataView\n * @param {number} offset The offset to start parsing from.\n * @param {number} length The length of all sub boxes combined.\n * @return {Array<Object>}\n */\nfunction parseSubBoxes(dataView, offset, length) {\n  const ACCEPTED_ITEM_INFO_TYPES = [ITEM_INFO_TYPE_EXIF, ITEM_INFO_TYPE_MIME];\n  const subBoxes = [];\n  let currentOffset = offset;\n  while (currentOffset < offset + length) {\n    const box = parseBox(dataView, currentOffset);\n    if (box === undefined) {\n      break;\n    }\n    if (box.type !== undefined && (box.itemType === undefined || ACCEPTED_ITEM_INFO_TYPES.indexOf(box.itemType) !== -1)) {\n      subBoxes.push(box);\n    }\n    currentOffset += box.length;\n  }\n  return subBoxes;\n}\nfunction parseItemInformationBox(dataView, startOffset, version, contentOffset, length) {\n  const {\n    offsets\n  } = getItemInformationBoxOffsetsAndSizes(version, contentOffset);\n  return {\n    type: 'iinf',\n    itemInfos: parseSubBoxes(dataView, offsets.itemInfos, length - (offsets.itemInfos - startOffset)),\n    length\n  };\n}\nfunction getItemInformationBoxOffsetsAndSizes(version, contentOffset) {\n  const FLAGS_SIZE = 3;\n  const offsets = {\n    entryCount: contentOffset + FLAGS_SIZE\n  };\n  const sizes = {};\n  if (version === 0) {\n    sizes.entryCount = 2;\n  } else {\n    sizes.entryCount = 4;\n  }\n  offsets.itemInfos = offsets.entryCount + sizes.entryCount;\n  return {\n    offsets\n  };\n}\nfunction parseItemInformationEntryBox(dataView, startOffset, version, contentOffset, length) {\n  const FLAGS_SIZE = 3;\n  contentOffset += FLAGS_SIZE;\n  const entry = {\n    type: 'infe',\n    length\n  };\n  if (version === 0 || version === 1) {\n    entry.itemId = dataView.getUint16(contentOffset);\n    contentOffset += 2;\n    entry.itemProtectionIndex = dataView.getUint16(contentOffset);\n    contentOffset += 2;\n    entry.itemName = getNullTerminatedStringFromDataView(dataView, contentOffset);\n    contentOffset += entry.itemName.length + 1;\n    // entry.contentType = getNullTerminatedStringFromDataView(dataView, offset);\n    // offset += entry.contentType.length + 1;\n    // Since contentEncoding is optional we need to check the offset against length here.\n    // entry.contentEncoding = getNullTerminatedStringFromDataView(dataView, offset);\n    // offset += entry.contentEncoding.length + 1;\n  }\n  // The following code should be correct but we currently don't need it.\n  // if (version === 1) {\n  //     // Everything here is optional, check the offset against length.\n  //     entry.extensionType = dataView.getUint32(contentOffset);\n  //     contentOffset += 4;\n  //     if (entry.extensionType === EXTENSION_TYPE_FDEL) {\n  //         entry.contentLocation = getNullTerminatedStringFromDataView(dataView, contentOffset);\n  //         contentOffset += entry.contentLocation.length + 1;\n  //         entry.contentMd5 = getNullTerminatedStringFromDataView(dataView, contentOffset);\n  //         contentOffset += entry.contentMd5.length + 1;\n  //         entry.contentLength = get64BitValue(dataView, contentOffset);\n  //         contentOffset += 8;\n  //         entry.transferLength = get64BitValue(dataView, contentOffset);\n  //         contentOffset += 8;\n  //         entry.entryCount = dataView.getUint8(contentOffset);\n  //         contentOffset += 1;\n  //         entry.entries = [];\n  //         for (let i = 0; i < entry.entryCount; i++) {\n  //             entry.entries.push({groupId: dataView.getUint32(contentOffset)});\n  //             contentOffset += 4;\n  //         }\n  //     }\n  // }\n  if (version >= 2) {\n    if (version === 2) {\n      entry.itemId = dataView.getUint16(contentOffset);\n      contentOffset += 2;\n    } else if (version === 3) {\n      entry.itemId = dataView.getUint32(contentOffset);\n      contentOffset += 4;\n    }\n    entry.itemProtectionIndex = dataView.getUint16(contentOffset);\n    contentOffset += 2;\n    // entry.itemTypeAscii = getStringFromDataView(dataView, offset, 4); // For testing.\n    entry.itemType = dataView.getUint32(contentOffset);\n    contentOffset += 4;\n    entry.itemName = getNullTerminatedStringFromDataView(dataView, contentOffset);\n    contentOffset += entry.itemName.length + 1;\n    if (entry.itemType === ITEM_INFO_TYPE_MIME) {\n      entry.contentType = getNullTerminatedStringFromDataView(dataView, contentOffset);\n      contentOffset += entry.contentType.length + 1;\n      if (startOffset + length > contentOffset) {\n        entry.contentEncoding = getNullTerminatedStringFromDataView(dataView, contentOffset);\n        contentOffset += entry.contentEncoding.length + 1;\n      }\n    } else if (entry.itemType === ITEM_INFO_TYPE_URI) {\n      entry.itemUri = getNullTerminatedStringFromDataView(dataView, contentOffset);\n      contentOffset += entry.itemUri.length + 1;\n    }\n  }\n  return entry;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}