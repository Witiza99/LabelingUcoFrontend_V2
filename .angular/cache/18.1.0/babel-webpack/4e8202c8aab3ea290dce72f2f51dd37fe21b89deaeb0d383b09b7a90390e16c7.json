{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nimport { iccTags, iccProfile } from './icc-tag-names.js';\nimport { getStringFromDataView, getUnicodeStringFromDataView, decompress, COMPRESSION_METHOD_NONE, COMPRESSION_METHOD_DEFLATE } from './utils.js';\nexport default {\n  read\n};\nconst PROFILE_HEADER_LENGTH = 84;\nconst ICC_TAG_COUNT_OFFSET = 128;\nconst ICC_SIGNATURE = 'acsp';\nconst TAG_TYPE_DESC = 'desc';\nconst TAG_TYPE_MULTI_LOCALIZED_UNICODE_TYPE = 'mluc';\nconst TAG_TYPE_TEXT = 'text';\nconst TAG_TYPE_SIGNATURE = 'sig ';\nconst TAG_TABLE_SINGLE_TAG_DATA = 12;\n\n// ICC profile data can be longer than application segment max length of ~64k.\n// so it can be split into multiple APP2 segments. Each segment includes\n// total chunk count and chunk number.\n// Here we read all chunks into single continuous array of bytes.\n// Compressed ICC profile data only has support for a single chunk.\nfunction read(dataView, iccData, async) {\n  if (async && iccData[0].compressionMethod !== COMPRESSION_METHOD_NONE) {\n    return readCompressedIcc(dataView, iccData);\n  }\n  return readIcc(dataView, iccData);\n}\nfunction readCompressedIcc(dataView, iccData) {\n  if (!compressionMethodIsSupported(iccData[0].compressionMethod)) {\n    return {};\n  }\n  const compressedDataView = new DataView(dataView.buffer.slice(iccData[0].offset, iccData[0].offset + iccData[0].length));\n  return decompress(compressedDataView, iccData[0].compressionMethod, 'utf-8', 'dataview').then(parseTags).catch(() => ({}));\n}\nfunction compressionMethodIsSupported(compressionMethod) {\n  return compressionMethod === COMPRESSION_METHOD_DEFLATE;\n}\nfunction readIcc(dataView, iccData) {\n  try {\n    const totalIccProfileLength = iccData.reduce((sum, icc) => sum + icc.length, 0);\n    const iccBinaryData = new Uint8Array(totalIccProfileLength);\n    let offset = 0;\n    const buffer = getBuffer(dataView);\n    for (let chunkNumber = 1; chunkNumber <= iccData.length; chunkNumber++) {\n      const iccDataChunk = iccData.find(x => x.chunkNumber === chunkNumber);\n      if (!iccDataChunk) {\n        throw new Error(`ICC chunk ${chunkNumber} not found`);\n      }\n      const data = buffer.slice(iccDataChunk.offset, iccDataChunk.offset + iccDataChunk.length);\n      const chunkData = new Uint8Array(data);\n      iccBinaryData.set(chunkData, offset);\n      offset += chunkData.length;\n    }\n    return parseTags(new DataView(iccBinaryData.buffer));\n  } catch (error) {\n    return {};\n  }\n}\nfunction getBuffer(dataView) {\n  if (Array.isArray(dataView)) {\n    return new DataView(Uint8Array.from(dataView).buffer).buffer;\n  }\n  return dataView.buffer;\n}\nfunction iccDoesNotHaveTagCount(buffer) {\n  return buffer.length < ICC_TAG_COUNT_OFFSET + 4;\n}\nfunction hasTagsData(buffer, tagHeaderOffset) {\n  return buffer.length < tagHeaderOffset + TAG_TABLE_SINGLE_TAG_DATA;\n}\nexport function parseTags(dataView) {\n  const buffer = dataView.buffer;\n  const length = dataView.getUint32();\n  if (dataView.byteLength !== length) {\n    throw new Error('ICC profile length not matching');\n  }\n  if (dataView.length < PROFILE_HEADER_LENGTH) {\n    throw new Error('ICC profile too short');\n  }\n  const tags = {};\n  const iccProfileKeys = Object.keys(iccProfile);\n  for (let i = 0; i < iccProfileKeys.length; i++) {\n    const offset = iccProfileKeys[i];\n    const profileEntry = iccProfile[offset];\n    const value = profileEntry.value(dataView, parseInt(offset, 10));\n    let description = value;\n    if (profileEntry.description) {\n      description = profileEntry.description(value);\n    }\n    tags[profileEntry.name] = {\n      value,\n      description\n    };\n  }\n  const signature = sliceToString(buffer.slice(36, 40));\n  if (signature !== ICC_SIGNATURE) {\n    throw new Error('ICC profile: missing signature');\n  }\n\n  /* ICC data is incomplete but we have header parsed so lets return it */\n  if (iccDoesNotHaveTagCount(buffer)) {\n    return tags;\n  }\n  const tagCount = dataView.getUint32(128);\n  let tagHeaderOffset = 132;\n  for (let i = 0; i < tagCount; i++) {\n    if (hasTagsData(buffer, tagHeaderOffset)) {\n      // Tags are corrupted (offset too far), return what we parsed until now\n      return tags;\n    }\n    const tagSignature = getStringFromDataView(dataView, tagHeaderOffset, 4);\n    const tagOffset = dataView.getUint32(tagHeaderOffset + 4);\n    const tagSize = dataView.getUint32(tagHeaderOffset + 8);\n    if (tagOffset > buffer.length) {\n      // Tag data is invalid, lets return what we managed to parse\n      return tags;\n    }\n    const tagType = getStringFromDataView(dataView, tagOffset, 4);\n    if (tagType === TAG_TYPE_DESC) {\n      const tagValueSize = dataView.getUint32(tagOffset + 8);\n      if (tagValueSize > tagSize) {\n        // Tag data is invalid, lets return what we managed to parse\n        return tags;\n      }\n      const val = sliceToString(buffer.slice(tagOffset + 12, tagOffset + tagValueSize + 11));\n      addTag(tags, tagSignature, val);\n    } else if (tagType === TAG_TYPE_MULTI_LOCALIZED_UNICODE_TYPE) {\n      const numRecords = dataView.getUint32(tagOffset + 8);\n      const recordSize = dataView.getUint32(tagOffset + 12);\n      let offset = tagOffset + 16;\n      const val = [];\n      for (let recordNum = 0; recordNum < numRecords; recordNum++) {\n        const languageCode = getStringFromDataView(dataView, offset + 0, 2);\n        const countryCode = getStringFromDataView(dataView, offset + 2, 2);\n        const textLength = dataView.getUint32(offset + 4);\n        const textOffset = dataView.getUint32(offset + 8);\n        const text = getUnicodeStringFromDataView(dataView, tagOffset + textOffset, textLength);\n        val.push({\n          languageCode,\n          countryCode,\n          text\n        });\n        offset += recordSize;\n      }\n      if (numRecords === 1) {\n        addTag(tags, tagSignature, val[0].text);\n      } else {\n        const valObj = {};\n        for (let valIndex = 0; valIndex < val.length; valIndex++) {\n          valObj[`${val[valIndex].languageCode}-${val[valIndex].countryCode}`] = val[valIndex].text;\n        }\n        addTag(tags, tagSignature, valObj);\n      }\n    } else if (tagType === TAG_TYPE_TEXT) {\n      const val = sliceToString(buffer.slice(tagOffset + 8, tagOffset + tagSize - 7));\n      addTag(tags, tagSignature, val);\n    } else if (tagType === TAG_TYPE_SIGNATURE) {\n      const val = sliceToString(buffer.slice(tagOffset + 8, tagOffset + 12));\n      addTag(tags, tagSignature, val);\n    }\n    tagHeaderOffset = tagHeaderOffset + 12;\n  }\n  return tags;\n}\nfunction sliceToString(slice) {\n  return String.fromCharCode.apply(null, new Uint8Array(slice));\n}\nfunction addTag(tags, tagSignature, value) {\n  if (iccTags[tagSignature]) {\n    tags[iccTags[tagSignature].name] = {\n      value,\n      description: value\n    };\n  } else {\n    tags[tagSignature] = {\n      value,\n      description: value\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}