{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport ByteOrder from './byte-order.js';\nimport Types from './types.js';\nimport { IFD_TYPE_MPF } from './tag-names.js';\nimport { deferInit, getBase64Image } from './utils.js';\nimport { readIfd, get0thIfdOffset } from './tags-helpers.js';\nexport default {\n  read\n};\nconst ENTRY_SIZE = 16;\nfunction read(dataView, dataOffset, includeUnknown) {\n  const byteOrder = ByteOrder.getByteOrder(dataView, dataOffset);\n  const tags = readIfd(dataView, IFD_TYPE_MPF, dataOffset, get0thIfdOffset(dataView, dataOffset, byteOrder), byteOrder, includeUnknown);\n  return addMpfImages(dataView, dataOffset, tags, byteOrder);\n}\nfunction addMpfImages(dataView, dataOffset, tags, byteOrder) {\n  if (!tags['MPEntry']) {\n    return tags;\n  }\n  const images = [];\n  for (let i = 0; i < Math.ceil(tags['MPEntry'].value.length / ENTRY_SIZE); i++) {\n    images[i] = {};\n    const attributes = getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE, Types.getTypeSize('LONG'), byteOrder);\n    images[i]['ImageFlags'] = getImageFlags(attributes);\n    images[i]['ImageFormat'] = getImageFormat(attributes);\n    images[i]['ImageType'] = getImageType(attributes);\n    const imageSize = getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE + 4, Types.getTypeSize('LONG'), byteOrder);\n    images[i]['ImageSize'] = {\n      value: imageSize,\n      description: '' + imageSize\n    };\n    const imageOffset = getImageOffset(i, tags['MPEntry'], byteOrder, dataOffset);\n    images[i]['ImageOffset'] = {\n      value: imageOffset,\n      description: '' + imageOffset\n    };\n    const dependentImage1EntryNumber = getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE + 12, Types.getTypeSize('SHORT'), byteOrder);\n    images[i]['DependentImage1EntryNumber'] = {\n      value: dependentImage1EntryNumber,\n      description: '' + dependentImage1EntryNumber\n    };\n    const dependentImage2EntryNumber = getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE + 14, Types.getTypeSize('SHORT'), byteOrder);\n    images[i]['DependentImage2EntryNumber'] = {\n      value: dependentImage2EntryNumber,\n      description: '' + dependentImage2EntryNumber\n    };\n    images[i].image = dataView.buffer.slice(imageOffset, imageOffset + imageSize);\n    deferInit(images[i], 'base64', function () {\n      return getBase64Image(this.image);\n    });\n  }\n  tags['Images'] = images;\n  return tags;\n}\nfunction getImageNumberValue(entries, offset, size, byteOrder) {\n  if (byteOrder === ByteOrder.LITTLE_ENDIAN) {\n    let value = 0;\n    for (let i = 0; i < size; i++) {\n      value += entries[offset + i] << 8 * i;\n    }\n    return value;\n  }\n  let value = 0;\n  for (let i = 0; i < size; i++) {\n    value += entries[offset + i] << 8 * (size - 1 - i);\n  }\n  return value;\n}\nfunction getImageFlags(attributes) {\n  const flags = [attributes >> 31 & 0x1, attributes >> 30 & 0x1, attributes >> 29 & 0x1];\n  const flagsDescription = [];\n  if (flags[0]) {\n    flagsDescription.push('Dependent Parent Image');\n  }\n  if (flags[1]) {\n    flagsDescription.push('Dependent Child Image');\n  }\n  if (flags[2]) {\n    flagsDescription.push('Representative Image');\n  }\n  return {\n    value: flags,\n    description: flagsDescription.join(', ') || 'None'\n  };\n}\nfunction getImageFormat(attributes) {\n  const imageFormat = attributes >> 24 & 0x7;\n  return {\n    value: imageFormat,\n    description: imageFormat === 0 ? 'JPEG' : 'Unknown'\n  };\n}\nfunction getImageType(attributes) {\n  const type = attributes & 0xffffff;\n  const descriptions = {\n    0x30000: 'Baseline MP Primary Image',\n    0x10001: 'Large Thumbnail (VGA equivalent)',\n    0x10002: 'Large Thumbnail (Full HD equivalent)',\n    0x20001: 'Multi-Frame Image (Panorama)',\n    0x20002: 'Multi-Frame Image (Disparity)',\n    0x20003: 'Multi-Frame Image (Multi-Angle)',\n    0x0: 'Undefined'\n  };\n  return {\n    value: type,\n    description: descriptions[type] || 'Unknown'\n  };\n}\nfunction getImageOffset(imageIndex, mpEntry, byteOrder, dataOffset) {\n  if (isFirstIndividualImage(imageIndex)) {\n    return 0;\n  }\n  return getImageNumberValue(mpEntry.value, imageIndex * ENTRY_SIZE + 8, Types.getTypeSize('LONG'), byteOrder) + dataOffset;\n}\nfunction isFirstIndividualImage(imageIndex) {\n  return imageIndex === 0;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}