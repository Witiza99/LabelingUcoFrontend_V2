{"ast":null,"code":"/*******************************Imports***********************************/\nimport { PLATFORM_ID } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../service/selectedtool.service\";\nimport * as i2 from \"../../service/propertierstool.service\";\nimport * as i3 from \"@angular/common\";\nconst _c0 = [\"canvas\"];\nfunction CanvasComponent_canvas_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"canvas\", 2, 0);\n    i0.ɵɵlistener(\"contextmenu\", function CanvasComponent_canvas_0_Template_canvas_contextmenu_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onContextMenu($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n//Class Canvas Component\nexport let CanvasComponent = /*#__PURE__*/(() => {\n  class CanvasComponent {\n    /*******************************Constructor***********************************/\n    constructor(toolService, propertierstoolService, platformId) {\n      this.toolService = toolService;\n      this.propertierstoolService = propertierstoolService;\n      this.platformId = platformId;\n      /*******************************Decorators***********************************/\n      this.image = null;\n      this.ctx = null;\n      this.loadedImage = null;\n      this.isCanvasReady = false;\n      this.selectedTool = '';\n      this.label = 'label';\n      this.color = '#FF0000';\n      this.thickness = 2;\n      //rectangles var\n      this.isClicked = false;\n      this.isDrawing = false;\n      this.startX = 0;\n      this.startY = 0;\n      this.currentX = 0;\n      this.currentY = 0;\n      this.isBrowser = isPlatformBrowser(this.platformId);\n    }\n    /******************************Angular_Functions*******************************/\n    //Load Image and subscribe to tool event\n    ngAfterViewInit() {\n      if (this.canvas && this.canvas.nativeElement) {\n        this.canvasnativeElement = this.canvas.nativeElement;\n        this.ctx = this.canvasnativeElement.getContext('2d');\n        if (!this.ctx) {\n          console.error('Ctx dont exist.');\n        }\n        this.isCanvasReady = true;\n      } else {\n        //console.error('La referencia al canvas no está definida.');\n      }\n      //tool subscription\n      this.toolSubscription = this.toolService.getSelectedToolObservable().subscribe({\n        next: tool => {\n          this.selectedTool = tool;\n        }\n      });\n      //tool propertiers subscription\n      this.toolPropertiesSubscription = this.subscribeToToolProperties();\n    }\n    subscribeToToolProperties() {\n      const labelSubscription = this.propertierstoolService.getLabelObservable().subscribe(label => {\n        this.label = label;\n      });\n      const colorSubscription = this.propertierstoolService.getColorObservable().subscribe(color => {\n        this.color = color;\n      });\n      const thicknessSubscription = this.propertierstoolService.getThicknessObservable().subscribe(thickness => {\n        this.thickness = thickness;\n      });\n      return new Subscription(() => {\n        labelSubscription.unsubscribe();\n        colorSubscription.unsubscribe();\n        thicknessSubscription.unsubscribe();\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes['image'] && this.isCanvasReady) {\n        this.loadImage();\n      }\n    }\n    ngOnDestroy() {\n      if (this.toolSubscription) {\n        this.toolSubscription.unsubscribe();\n      }\n      if (this.toolPropertiesSubscription) {\n        this.toolPropertiesSubscription.unsubscribe();\n      }\n    }\n    /************************Getter_and_Setter_Funtions***************************/\n    getSelectedTool() {\n      return this.selectedTool;\n    }\n    /******************************Others_Functions*******************************/\n    //Listeners\n    onMouseDown(event) {\n      if (event.button === 0) {\n        // Left click\n        switch (this.selectedTool) {\n          case 'rectangle':\n            this.startRectangleDrawing(event);\n            break;\n          case 'circle':\n            break;\n          case 'poligone':\n            break;\n        }\n        this.isClicked = true;\n        this.isDrawing = false;\n      }\n    }\n    onMouseMove(event) {\n      if (this.isClicked) {\n        this.isDrawing = true;\n        switch (this.selectedTool) {\n          case 'rectangle':\n            this.updateRectangleDrawing(event);\n            break;\n          case 'circle':\n            break;\n          case 'poligone':\n            break;\n        }\n      }\n    }\n    onMouseUp(event) {\n      if (event.button === 0 && this.isClicked) {\n        if (this.isDrawing) {\n          switch (this.selectedTool) {\n            case 'rectangle':\n              this.finishRectangleDrawing(event);\n              break;\n            case 'circle':\n              break;\n            case 'poligone':\n              break;\n          }\n          this.isDrawing = false;\n        }\n        this.isClicked = false;\n      }\n    }\n    onMouseLeave(event) {\n      if (this.isClicked) {\n        this.isClicked = false;\n        this.isDrawing = false;\n        // Stop drawing, draw image again\n        this.drawImage();\n      }\n    }\n    onContextMenu(event) {\n      event.preventDefault(); // Prevent context menu from appearing\n      switch (this.selectedTool) {\n        case 'rectangle':\n          this.removeRectangle(event);\n          break;\n        case 'circle':\n          break;\n        case 'poligone':\n          break;\n      }\n    }\n    //Save image to load in canvas\n    loadImage() {\n      if (this.image && this.image.file) {\n        if (this.ctx) {\n          const img = new Image();\n          img.src = URL.createObjectURL(this.image.file);\n          img.onload = () => {\n            this.loadedImage = img;\n            this.drawImage();\n          };\n        }\n      } else {\n        this.clearCanvas();\n      }\n    }\n    //draw methots\n    //draw metadata on image canvas\n    drawImage() {\n      if (this.loadedImage && this.image) {\n        if (this.ctx != null) {\n          this.ctx.clearRect(0, 0, this.canvasnativeElement.width, this.canvasnativeElement.height);\n          this.ctx.drawImage(this.loadedImage, 0, 0, this.canvasnativeElement.width, this.canvasnativeElement.height);\n          if (this.image.metadata) {\n            // Iterate all metadata\n            this.image.metadata.forEach(shape => {\n              this.drawShape(shape); // Call a methot for draw that shape\n            });\n          }\n        }\n      }\n    }\n    //draw specific shape on image canvas\n    drawShape(shape) {\n      if (this.ctx) {\n        // Check ctx is defined\n        switch (shape.type) {\n          case 'rectangle':\n            this.drawRectangles(shape);\n            break;\n          case 'circle':\n            //this.drawCircle(shape);\n            break;\n          case 'polygon':\n            //this.drawPolygon(shape);\n            break;\n          // More case\n          default:\n            break;\n        }\n      } else {\n        console.error('Context 2D is not defined');\n      }\n    }\n    //draw renctangle shape\n    drawRectangles(shape) {\n      if (this.ctx) {\n        const canvasWidth = this.canvasnativeElement.width;\n        const canvasHeight = this.canvasnativeElement.height;\n        // Get coords and width/height with canvas resolution\n        const x_center = shape.x * canvasWidth;\n        const y_center = shape.y * canvasHeight;\n        const width = shape.width * canvasWidth;\n        const height = shape.height * canvasHeight;\n        // Get upper left corner\n        const x1 = x_center - width / 2;\n        const y1 = y_center - height / 2;\n        // Draw rectangle with metadata\n        this.ctx.strokeStyle = shape.color;\n        this.ctx.lineWidth = shape.thickness;\n        this.ctx.strokeRect(x1, y1, width, height);\n        this.drawLabel(x1, y1, shape.color, shape.label, shape.thickness);\n      }\n    }\n    //remove rectagle from image\n    removeRectangle(event) {\n      if (this.image && this.image.metadata) {\n        const canvasWidth = this.canvasnativeElement.width;\n        const canvasHeight = this.canvasnativeElement.height;\n        const rect = this.canvasnativeElement.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        let removed = false;\n        this.image.metadata = this.image.metadata.filter(shape => {\n          if (shape.type === 'rectangle') {\n            // Get coords and width/height with canvas resolution for upper left corner\n            const rectX1 = (shape.x - shape.width / 2) * this.canvasnativeElement.width;\n            const rectY1 = (shape.y - shape.height / 2) * this.canvasnativeElement.height;\n            const rectX2 = rectX1 + shape.width * this.canvasnativeElement.width;\n            const rectY2 = rectY1 + shape.height * this.canvasnativeElement.height;\n            // Check if event coords are inside box\n            if (x >= rectX1 && x <= rectX2 && y >= rectY1 && y <= rectY2) {\n              removed = true;\n              return false;\n            }\n          }\n          return true;\n        });\n        if (removed) {\n          this.drawImage(); // Redraw after removing the rectangle\n        }\n      }\n    }\n    //Rectangle methods\n    startRectangleDrawing(event) {\n      const canvas = this.canvas.nativeElement;\n      const rect = canvas.getBoundingClientRect();\n      this.startX = event.clientX - rect.left;\n      this.startY = event.clientY - rect.top;\n    }\n    updateRectangleDrawing(event) {\n      if (this.ctx && this.loadedImage) {\n        this.currentX = event.clientX - this.canvasnativeElement.getBoundingClientRect().left;\n        this.currentY = event.clientY - this.canvasnativeElement.getBoundingClientRect().top;\n        // Clear and redraw the image\n        this.ctx.clearRect(0, 0, this.canvasnativeElement.width, this.canvasnativeElement.height);\n        this.ctx.drawImage(this.loadedImage, 0, 0, this.canvasnativeElement.width, this.canvasnativeElement.height);\n        // Draw existing shapes from metadata\n        if (this.image) {\n          if (this.image.metadata) {\n            this.image.metadata.forEach(shape => {\n              this.drawShape(shape);\n            });\n          }\n        }\n        // Draw the current rectangle being manipulated\n        this.ctx.strokeStyle = this.invertColor(this.color);\n        this.ctx.lineWidth = this.thickness;\n        this.ctx.strokeRect(this.startX, this.startY, this.currentX - this.startX, this.currentY - this.startY);\n      }\n    }\n    finishRectangleDrawing(event) {\n      if (this.image && this.loadedImage) {\n        const canvas = this.canvas.nativeElement;\n        // Get upper left corner\n        const x1 = Math.min(this.startX, this.currentX);\n        const y1 = Math.min(this.startY, this.currentY);\n        const width = Math.abs(this.currentX - this.startX);\n        const height = Math.abs(this.currentY - this.startY);\n        // Get center\n        const x_center = x1 + width / 2;\n        const y_center = y1 + height / 2;\n        // Get canvas width and height\n        const canvasWidth = canvas.width;\n        const canvasHeight = canvas.height;\n        // Normalize canvas size\n        const normalized_x_center = x_center / canvasWidth;\n        const normalized_y_center = y_center / canvasHeight;\n        const normalized_width = width / canvasWidth;\n        const normalized_height = height / canvasHeight;\n        // Create shape object to shave metadata\n        const newShape = {\n          type: 'rectangle',\n          x: normalized_x_center,\n          y: normalized_y_center,\n          width: normalized_width,\n          height: normalized_height,\n          color: this.color,\n          label: this.label,\n          thickness: this.thickness\n        };\n        // Yolo format\n        //const yoloFormat = `${this.label} ${normalized_x_center.toFixed(6)} ${normalized_y_center.toFixed(6)} ${normalized_width.toFixed(6)} ${normalized_height.toFixed(6)}`;\n        // Add new shape to metadata\n        if (!this.image.metadata) {\n          this.image.metadata = [];\n        }\n        this.image.metadata.push(newShape);\n        // Draw image again\n        this.drawImage();\n      }\n    }\n    drawLabel(x, y, color, label, thickness) {\n      if (this.ctx) {\n        const fontSize = Math.max(12, Math.min(thickness * 5, 24)); // Adjust size font\n        this.ctx.fillStyle = color; // label color\n        this.ctx.font = `${fontSize}px Arial`; // font size\n        this.ctx.fillText(label, x, y - 5); // label name and position  \n      }\n    }\n    invertColor(hex) {\n      // Hex have 6 characters(can include '#')\n      if (hex.charAt(0) === '#') {\n        hex = hex.substring(1);\n      }\n      // Parse red, green and blue to hex\n      const r = parseInt(hex.substring(0, 2), 16);\n      const g = parseInt(hex.substring(2, 4), 16);\n      const b = parseInt(hex.substring(4, 6), 16);\n      // Invertir each component\n      const invertedR = (255 - r).toString(16).padStart(2, '0');\n      const invertedG = (255 - g).toString(16).padStart(2, '0');\n      const invertedB = (255 - b).toString(16).padStart(2, '0');\n      // Build invert color\n      return `#${invertedR}${invertedG}${invertedB}`;\n    }\n    clearCanvas() {\n      if (this.ctx) {\n        this.ctx.clearRect(0, 0, this.canvasnativeElement.width, this.canvasnativeElement.height);\n        this.loadedImage = null;\n      }\n    }\n    static #_ = this.ɵfac = function CanvasComponent_Factory(t) {\n      return new (t || CanvasComponent)(i0.ɵɵdirectiveInject(i1.ToolService), i0.ɵɵdirectiveInject(i2.PropertierstoolService), i0.ɵɵdirectiveInject(PLATFORM_ID));\n    };\n    static #_2 = this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: CanvasComponent,\n      selectors: [[\"app-canvas\"]],\n      viewQuery: function CanvasComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n        }\n      },\n      hostBindings: function CanvasComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"mousedown\", function CanvasComponent_mousedown_HostBindingHandler($event) {\n            return ctx.onMouseDown($event);\n          })(\"mousemove\", function CanvasComponent_mousemove_HostBindingHandler($event) {\n            return ctx.onMouseMove($event);\n          })(\"mouseup\", function CanvasComponent_mouseup_HostBindingHandler($event) {\n            return ctx.onMouseUp($event);\n          })(\"mouseleave\", function CanvasComponent_mouseleave_HostBindingHandler($event) {\n            return ctx.onMouseLeave($event);\n          });\n        }\n      },\n      inputs: {\n        image: \"image\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 1,\n      vars: 1,\n      consts: [[\"canvas\", \"\"], [\"class\", \"border-4 border-black\", \"width\", \"854\", \"height\", \"480\", 3, \"contextmenu\", 4, \"ngIf\"], [\"width\", \"854\", \"height\", \"480\", 1, \"border-4\", \"border-black\", 3, \"contextmenu\"]],\n      template: function CanvasComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, CanvasComponent_canvas_0_Template, 2, 0, \"canvas\", 1);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngIf\", ctx.isBrowser);\n        }\n      },\n      dependencies: [i3.NgIf],\n      encapsulation: 2\n    });\n  }\n  return CanvasComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}