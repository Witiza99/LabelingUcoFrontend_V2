{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Specification: http://www.libpng.org/pub/png/spec/1.2/\n\nimport { getStringValueFromArray, getStringFromDataView, decompress, COMPRESSION_METHOD_NONE } from './utils.js';\nimport TagDecoder from './tag-decoder.js';\nimport { TYPE_TEXT, TYPE_ITXT, TYPE_ZTXT } from './image-header-png.js';\nimport Tags from './tags.js';\nimport IptcTags from './iptc-tags.js';\nimport Constants from './constants.js';\nexport default {\n  read\n};\nconst STATE_KEYWORD = 'STATE_KEYWORD';\nconst STATE_COMPRESSION = 'STATE_COMPRESSION';\nconst STATE_LANG = 'STATE_LANG';\nconst STATE_TRANSLATED_KEYWORD = 'STATE_TRANSLATED_KEYWORD';\nconst STATE_TEXT = 'STATE_TEXT';\nconst COMPRESSION_SECTION_ITXT_EXTRA_BYTE = 1;\nconst COMPRESSION_FLAG_COMPRESSED = 1;\nconst EXIF_OFFSET = 6;\nfunction read(dataView, pngTextChunks, async, includeUnknown) {\n  const tags = {};\n  const tagsPromises = [];\n  for (let i = 0; i < pngTextChunks.length; i++) {\n    const {\n      offset,\n      length,\n      type\n    } = pngTextChunks[i];\n    const nameAndValue = getNameAndValue(dataView, offset, length, type, async);\n    if (nameAndValue instanceof Promise) {\n      tagsPromises.push(nameAndValue.then(({\n        name,\n        value,\n        description\n      }) => {\n        try {\n          if (Constants.USE_EXIF && isExifGroupTag(name, value)) {\n            return {\n              __exif: Tags.read(decodeRawData(value), EXIF_OFFSET, includeUnknown)\n            };\n          } else if (Constants.USE_IPTC && isIptcGroupTag(name, value)) {\n            return {\n              __iptc: IptcTags.read(decodeRawData(value), 0, includeUnknown)\n            };\n          } else if (name) {\n            return {\n              [name]: {\n                value,\n                description\n              }\n            };\n          }\n        } catch (error) {\n          // Ignore the broken tag.\n        }\n        return {};\n      }));\n    } else {\n      const {\n        name,\n        value,\n        description\n      } = nameAndValue;\n      if (name) {\n        tags[name] = {\n          value,\n          description\n        };\n      }\n    }\n  }\n  return {\n    readTags: tags,\n    readTagsPromise: tagsPromises.length > 0 ? Promise.all(tagsPromises) : undefined\n  };\n}\nfunction getNameAndValue(dataView, offset, length, type, async) {\n  const keywordChars = [];\n  const langChars = [];\n  const translatedKeywordChars = [];\n  let valueChars;\n  let parsingState = STATE_KEYWORD;\n  let compressionMethod = COMPRESSION_METHOD_NONE;\n  for (let i = 0; i < length && offset + i < dataView.byteLength; i++) {\n    if (parsingState === STATE_COMPRESSION) {\n      compressionMethod = getCompressionMethod({\n        type,\n        dataView,\n        offset: offset + i\n      });\n      if (type === TYPE_ITXT) {\n        i += COMPRESSION_SECTION_ITXT_EXTRA_BYTE;\n      }\n      parsingState = moveToNextState(type, parsingState);\n      continue;\n    } else if (parsingState === STATE_TEXT) {\n      valueChars = new DataView(dataView.buffer.slice(offset + i, offset + length));\n      break;\n    }\n    const byte = dataView.getUint8(offset + i);\n    if (byte === 0) {\n      parsingState = moveToNextState(type, parsingState);\n    } else if (parsingState === STATE_KEYWORD) {\n      keywordChars.push(byte);\n    } else if (parsingState === STATE_LANG) {\n      langChars.push(byte);\n    } else if (parsingState === STATE_TRANSLATED_KEYWORD) {\n      translatedKeywordChars.push(byte);\n    }\n  }\n  if (compressionMethod !== COMPRESSION_METHOD_NONE && !async) {\n    return {};\n  }\n  const decompressedValueChars = decompress(valueChars, compressionMethod, getEncodingFromType(type));\n  if (decompressedValueChars instanceof Promise) {\n    return decompressedValueChars.then(_decompressedValueChars => constructTag(_decompressedValueChars, type, langChars, keywordChars)).catch(() => constructTag('<text using unknown compression>'.split(''), type, langChars, keywordChars));\n  }\n  return constructTag(decompressedValueChars, type, langChars, keywordChars);\n}\nfunction getCompressionMethod({\n  type,\n  dataView,\n  offset\n}) {\n  if (type === TYPE_ITXT) {\n    if (dataView.getUint8(offset) === COMPRESSION_FLAG_COMPRESSED) {\n      return dataView.getUint8(offset + 1);\n    }\n  } else if (type === TYPE_ZTXT) {\n    return dataView.getUint8(offset);\n  }\n  return COMPRESSION_METHOD_NONE;\n}\nfunction moveToNextState(type, parsingState) {\n  if (parsingState === STATE_KEYWORD && [TYPE_ITXT, TYPE_ZTXT].includes(type)) {\n    return STATE_COMPRESSION;\n  }\n  if (parsingState === STATE_COMPRESSION) {\n    if (type === TYPE_ITXT) {\n      return STATE_LANG;\n    }\n    return STATE_TEXT;\n  }\n  if (parsingState === STATE_LANG) {\n    return STATE_TRANSLATED_KEYWORD;\n  }\n  return STATE_TEXT;\n}\nfunction getEncodingFromType(type) {\n  if (type === TYPE_TEXT || type === TYPE_ZTXT) {\n    return 'latin1';\n  }\n  return 'utf-8';\n}\nfunction constructTag(valueChars, type, langChars, keywordChars) {\n  const value = getValue(valueChars);\n  return {\n    name: getName(type, langChars, keywordChars),\n    value,\n    description: type === TYPE_ITXT ? getDescription(valueChars) : value\n  };\n}\nfunction getName(type, langChars, keywordChars) {\n  const name = getStringValueFromArray(keywordChars);\n  if (type === TYPE_TEXT || langChars.length === 0) {\n    return name;\n  }\n  const lang = getStringValueFromArray(langChars);\n  return `${name} (${lang})`;\n}\nfunction getValue(valueChars) {\n  if (valueChars instanceof DataView) {\n    return getStringFromDataView(valueChars, 0, valueChars.byteLength);\n  }\n  return valueChars;\n}\nfunction getDescription(valueChars) {\n  return TagDecoder.decode('UTF-8', valueChars);\n}\nfunction isExifGroupTag(name, value) {\n  return name.toLowerCase() === 'raw profile type exif' && value.substring(1, 5) === 'exif';\n}\nfunction isIptcGroupTag(name, value) {\n  return name.toLowerCase() === 'raw profile type iptc' && value.substring(1, 5) === 'iptc';\n}\nfunction decodeRawData(value) {\n  const parts = value.match(/\\n(exif|iptc)\\n\\s*\\d+\\n([\\s\\S]*)$/);\n  return hexToDataView(parts[2].replace(/\\n/g, ''));\n}\nfunction hexToDataView(hex) {\n  const dataView = new DataView(new ArrayBuffer(hex.length / 2));\n  for (let i = 0; i < hex.length; i += 2) {\n    dataView.setUint8(i / 2, parseInt(hex.substring(i, i + 2), 16));\n  }\n  return dataView;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}